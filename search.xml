<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F03%2F10%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[Markdown的使用]]></title>
    <url>%2F2019%2F02%2F02%2FMarkdown%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[这是一个标题这是另一个标题 这是第一行标题 这是第一行列表项。 这是第二行列表项。 给出一些例子代码： return shell_exec(“echo $input | $markdown_script”); hello java android ios hello xvdfgd dfsdf dfdf 百度single asteriskssingle asterisks 比如说printf(&quot;hello world)之后也可以 [图片上传失败…(image-4a2488-1553434701067)] 序号 交易名 交易说明 备注 1 prfcfg 菜单配置 可以通过此交易的对应关系 2 gentmo 编译所有交易 p 100000 sysdba 数据库表模型汇总 hel 删除号这是一个注脚测试^注释1]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ijkplayer编译的踩坑之路]]></title>
    <url>%2F2018%2F12%2F02%2Fijkplayer%E7%BC%96%E8%AF%91%E7%9A%84%E8%B8%A9%E5%9D%91%E4%B9%8B%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[一、编译缘由：公司业务需要集成播放器，市面上用的比较多的是B端的ijkplayer播放器，使用方便，功能也比较强大，所在就采用了ijkplayer。项目的要求支持的mp4,3gp,rmvp,rm,avi,mov,mpg,flv封装格式和https协议，而且ijkplayer默认的编译的格式比较少，所以要重新编译，不过在编译的过程出现了各种问题，各种坑，所以记录一下，省得后人来踩。 二、编译历程编译ijkplayer播放器要在linux环境下生成so,小编之前都是在windows上进行开发，没有在linux上开发过，对linux指令不是很熟悉，所以就想在简单的在windows配置环境，采用了Cygwin，后来我发现在我错了，装了Cygwin后，出错了这么多软件和环境的问题。后来放弃了，采用虚拟机，VMware+Ubuntu,其实这个方式更简单，只需要在官网下载安装即可，安装的时候给ubuntu的空间可以大一点，我的是60G，小的话可能会提示空间不足。于是就兴高采烈在开始编译了。按照着https://github.com/Bilibili/ijkplayer官网上的步骤来，卧槽，不行啊。后来通过不断的尝试和查找，终于编译成功了，下面的我尝试的正确步骤。 1、配置环境 install homebrew, git, yasmruby -e “$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;brew install gitbrew install yasm去官网下载解压jdk,sdk,ndk,ndk版本用的是r10e的$sudo gedit ~/.bashrc 将一下内容粘贴到文档最底部（具体路径以自己的机器为准） export JAVA_HOME=/home/tan/Android/jdk1.7.0_79export JRE_HOME=/home/tan/android/jdk1.7.0_79/jreexport CLASSPATH=.:$CLASSPATH:$JAVA_HOME/lib:$JAVA_HOME/jre/libexport PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/binexport ANDROID_SDK=/home/tan/android/android-sdk-linuxexport PATH=$PATH:$ANDROID_SDK/platform-tools:$ANDROID_SDK/toolsexport ANDROID_NDK=/home/tan/android/android-ndk-r13bexport ANDROID_NDK 保存，输入命令：source ~/.bashrc 使环境生效 2、编译之前 git clone https://github.com/Bilibili/ijkplayer.git ijkplayer-androidcd ijkplayer-androidgit checkout -B latest k0.8.8 配置编译支持所有格式cd config先打开module-default.sh，在尾部添加下面代码，要不然会编译失败，这里是一个大坑export COMMON_FF_CFG_FLAGS=”$COMMON_FF_CFG_FLAGS –disable-linux-perf”export COMMON_FF_CFG_FLAGS=”$COMMON_FF_CFG_FLAGS –disable-bzlib” rm module.shln -s module-default.sh module.shcd android/contribsh compile-ffmpeg.sh clean ok,真正要开始编译了回到项目根目录cd ijkplayer-android./init-android-openssl.sh //这里是配置ssl，https协议./init-android.sh这里下载ffmpeg和预编译内容，比较耗时，可以喝一杯咖啡先，完成后接着cd android/contrib./compile-openssl.sh clean./compile-ffmpeg.sh clean./compile-openssl.sh all./compile-ffmpeg.sh all这里的编译也比较耗时，不过等待的就是成功的喜悦啦结束后，编译就完成了，接下来就是生成so文件 cd .../compile-ijk.sh all 生成过程还不太久，会在/ijkplayer-android/android/ijkplayer目录下生成我们所想要的包，生成的包还挺大的。每一个步骤都是比较重要的，落掉某个步骤可能就会导入生成失败，每次的编译生成过程也是比较耗时的，所以少踩点坑就可以节约很多时间。 三、视频相关技术雷霄骅的 总结视音频编解码技术零基础学习方法]]></content>
      <categories>
        <category>android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android单元测试之Mockito的使用]]></title>
    <url>%2F2018%2F12%2F02%2FAndroid%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%B9%8BMockito%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Mockito最大的特点是模拟依赖， 添加依赖 testImplementation &quot;org.mockito:mockito-core:2.11.0&quot; 1. 四种Mock方式 使用mock方法 12345@Test public void test()&#123; Calculator calculator=mock(Calculator.class);//使用mock方法 Assert.assertNotNull(calculator); &#125; 使用@Mock注解 123456789101112@MockCalculator calculator;@Beforepublic void setup()&#123; MockitoAnnotations.initMocks(this);//初始化&#125;@Testpublic void test1()&#123; Assert.assertNotNull(calculator);&#125; 在使用注解之前要调用MockitoAnnotations.initMocks(this);来初始化mock 运行器方式 123456789@RunWith(MockitoJUnitRunner.class)//使用MockitoJUnitRunner运行器public class MockTest &#123; @Mock Calculator calculator; @Test public void test2()&#123; Assert.assertNotNull(calculator); &#125;&#125; MockitoRule方法 12345678910@MockCalculator calculator;@Rulepublic MockitoRule mockitoRule = MockitoJUnit.rule();@Testpublic void test3()&#123; Assert.assertNotNull(calculator);&#125; 2. 常用打桩方法打桩的意思是对mock出来的对象进行操作，比如模拟返回值 方法名 方法描述 thenReturn(T value) 设置要返回的值 thenThrow(Throwable… throwables) thenThrow(Throwable… throwables) thenAnswer(Answer&lt;?&gt; answer) 对结果进行拦截 doReturn(Object toBeReturned) 提前设置要返回的值 doThrow(Throwable… toBeThrown) 提前设置要抛出的异常 doAnswer(Answer answer) 提前对结果进行拦截 doCallRealMethod() 调用某一个方法的真实实现 doNothing() 设置void方法什么也不做 比如Calculator文件有方法 123public String getMyName()&#123; return &quot;leory&quot;; &#125; 通过单元测试可以模拟更改返回值12when(calculator.getMyName()).thenReturn(&quot;hello,leory&quot;);System.out.print(calculator.getMyName()); 输出hello,leory doReturn主要是对无法用thenReturn的情况，比如返回值void12doReturn(&quot;小明&quot;).when(calculator).getMyName();System.out.print(calculator.getMyName()); 输出 小明 3. 常用验证方法 上面所说的都是状态测试，所关心的是返回结果，但如果关心方法是否被正确的参数调用过，这时候就要调用验证方法了 通过verify(T mock)验证发生的某些行为 。 方法名 方法描述 after(long millis) 一段时间后再验证 timeout(long millis) 验证方法执行是否超时 atLeast(int minNumberOfInvocations) 至少执行多少次 atMost(int maxNumberOfInvocations) 至多进行n次验证 description(String description) 验证失败时输出的内容 times(int wantedNumberOfInvocations) 验证调用方法的次数 never() 验证交互没有发生,相当于times(0) only() 验证方法只被调用一次，相当于times(1) 4. 常用参数匹配器 方法名 方法描述 anyObject() 匹配任何对象 any(Class type) 与anyObject()一样 any() 与anyObject()一样 anyBoolean() 匹配任何boolean和非空Boolean anyByte() 匹配任何byte和非空Byte anyCollection() 匹配任何非空Collection anyDouble() 匹配任何double和非空Double anyFloat() 匹配任何double和非空Double anyInt() 匹配任何int和非空Integer anyList() 匹配任何非空List anyLong() 匹配任何long和非空Long anyMap() 匹配任何非空Map anyString() 匹配任何非空String contains(String substring) 参数包含给定的substring字符串 argThat(ArgumentMatcher matcher) 创建自定义的参数匹配模式 举个栗子参数为aynInt()12345@Testpublic void test5()&#123; when(calculator.add(anyInt(),anyInt())).thenReturn(100); Assert.assertEquals(100,calculator.add(1,2));&#125; 参数包含某个string123456@Testpublic void test5()&#123; when(calculator.judgeInput(contains(&quot;朱&quot;))).thenReturn(&quot;朱&quot;); Assert.assertEquals(&quot;小朱&quot;,calculator.judgeInput(&quot;小朱&quot;));&#125; 5. 其他方法 方法名 方法描述 reset(T … mocks) 重置Mock spy(Class classToSpy) 实现调用真实对象的实现 inOrder(Object… mocks) 验证执行顺序 @InjectMocks注解 自动将模拟对象注入到被测试对象中 参考 Android单元测试(二)：Mockito框架的使用]]></content>
      <categories>
        <category>android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android屏幕适配]]></title>
    <url>%2F2018%2F12%2F02%2FAndroid%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D%2F</url>
    <content type="text"><![CDATA[一. 为什么要适配屏幕android屏幕大小、屏幕密度碎片化严重 二. 怎么样适配屏幕图片适配应用图标提供不同版本的尺寸 ldpi（低） mdpi（中）48*48 hdpi（高）72*72 xhdpi（超高）96*96 xxhdpi（超超高）144*144 xxxhdpi（超超超高）192*192 普通图标只给一套图片，sdk会根据当前屏幕密度选择比较接近的图片 利用.9图片，防止拉伸 布局适配结合weight的使用利用百分比适配平板，加载layout-sw600dp文件夹的布局 三. 使用第三方自适应库今日头条适配方案今日头条适配方案 今日头条屏幕适配方案的核心原理在于，根据以下公式算出 density 当前设备屏幕总宽度（单位为像素）/ 设计图总宽度（单位为 dp) = density smallestWidth 限定符屏幕适配方案smallestWidth 限定符适配方案]]></content>
      <categories>
        <category>android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android性能优化]]></title>
    <url>%2F2018%2F12%2F02%2FAndroid%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[Android性能优化主要有下面几个方面 内存优化 UI优化(布局优化和绘制优化) 速度优化 电量优化 启动优化 参考文章 Android性能优化全方面解析]]></content>
      <categories>
        <category>android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android插件化]]></title>
    <url>%2F2018%2F12%2F02%2FAndroid%E6%8F%92%E4%BB%B6%E5%8C%96%2F</url>
    <content type="text"><![CDATA[插件化涉及的东西很多，下面从基础知识、插件化技术和主流的插件化框架来介绍 基础知识 #####类加载器原理 #####反射原理 #####代理模式及Java实现动态代理 插件化技术 #####插件化开发—动态加载技术加载已安装和未安装的apk]]></content>
      <categories>
        <category>android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android知识总结]]></title>
    <url>%2F2018%2F12%2F02%2FAndroid%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[一、Android动画Android 属性动画：这是一篇很详细的 属性动画 总结&amp;攻略 二、自定义View 爱哥的—自定义View其实很简单 GcsSloop—自定义View系列 三、内存管理 内存泄漏 四、Android进程框架 进程的启动创建、启动与调度流程 五、IPC原理 IPC机制 AIDL使用解析 AIDL使用详解及原理 六、事件分发机制 图解 Android 事件分发机制 七、滑动事件 View的事件体系(二)实现View滑动的三种方式 站在源码的肩膀上全解Scroller工作机制 Android实现滑动的几种方法 笔记：getLeft()=translateX+marginLeft 八、Handler机制 Android 异步消息处理机制 让你深入理解 Looper、Handler、Message三者关系]]></content>
      <categories>
        <category>android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android进程保活]]></title>
    <url>%2F2018%2F12%2F02%2FAndroid%E8%BF%9B%E7%A8%8B%E4%BF%9D%E6%B4%BB%2F</url>
    <content type="text"><![CDATA[1、进程类别下面的进程的优先级从高到低，系统在内存不足时优先越低，进程越容易被杀死。 1.1、前台进程 某个进程持有一个正在与用户交互的Activity并且该Activity正处于resume的状态。 某个进程持有一个Service，并且该Service与用户正在交互的Activity绑定。 某个进程持有一个Service，并且该Service调用startForeground()方法使之位于前台运行。 某个进程持有一个Service，并且该Service正在执行它的某个生命周期回调方法，比如onCreate()、 onStart()或onDestroy()。 某个进程持有一个BroadcastReceiver，并且该BroadcastReceiver正在执行其onReceive()方法。 用户正在使用的程序，一般系统是不会杀死前台进程的，除非用户强制停止应用或者系统内存不足等极端情况会杀死。 1.2、可见进程 拥有不在前台、但仍对用户可见的 Activity（已调用 onPause()）。 拥有绑定到可见（或前台）Activity 的 Service 用户正在使用，看得到，但是摸不着，没有覆盖到整个屏幕,只有屏幕的一部分可见进程不包含任何前台组件，一般系统也是不会杀死可见进程的，除非要在资源吃紧的情况下，要保持某个或多个前台进程存活 1.3、服务进程 某个进程中运行着一个Service且该Service是通过startService()启动的，与用户看见的界面没有直接关联。 在内存不足以维持所有前台进程和可见进程同时运行的情况下，服务进程会被杀死 1.4、后台进程 在用户按了”back”或者”home”后,程序本身看不到了,但是其实还在运行的程序，比如Activity调用了onStop方法 1.5、空进程 某个进程不包含任何活跃的组件时该进程就会被置为空进程，完全没用,杀了它只有好处没坏处,第一个干它! 2、进程保活方案2.1、开启一个像素的Activity据说这个是手Q的进程保活方案，基本思想，系统一般是不会杀死前台进程的。所以要使得进程常驻，我们只需要在锁屏的时候在本进程开启一个Activity，为了欺骗用户，让这个Activity的大小是1像素，并且透明无切换动画，在开屏幕的时候，把这个Activity关闭掉，所以这个就需要监听系统锁屏广播。 2.2、前台服务就是把服务设置成前台进程，据说这个微信也用过的进程保活方案，移步微信Android客户端后台保活经验分享，这方案实际利用了Android前台service的漏洞。方法如下 对于 API level &lt; 18 ：调用startForeground(ID， new Notification())，发送空的Notification ，图标则不会显示。 对于 API level &gt;= 18：在需要提优先级的service A启动一个InnerService，两个服务同时startForeground，且绑定同样的 ID。Stop 掉InnerService ，这样通知栏图标即被移除。代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class KeepLiveService extends Service &#123; public static final int NOTIFICATION_ID=0x11; public KeepLiveService() &#123; &#125; @Override public IBinder onBind(Intent intent) &#123; throw new UnsupportedOperationException(&quot;Not yet implemented&quot;); &#125; @Override public void onCreate() &#123; super.onCreate(); //API 18以下，直接发送Notification并将其置为前台 if (Build.VERSION.SDK_INT &lt;Build.VERSION_CODES.JELLY_BEAN_MR2) &#123; startForeground(NOTIFICATION_ID, new Notification()); &#125; else &#123; //API 18以上，发送Notification并将其置为前台后，启动InnerService Notification.Builder builder = new Notification.Builder(this); builder.setSmallIcon(R.mipmap.ic_launcher); startForeground(NOTIFICATION_ID, builder.build()); startService(new Intent(this, InnerService.class)); &#125; &#125; public class InnerService extends Service&#123; @Override public IBinder onBind(Intent intent) &#123; return null; &#125; @Override public void onCreate() &#123; super.onCreate(); //发送与KeepLiveService中ID相同的Notification，然后将其取消并取消自己的前台显示 Notification.Builder builder = new Notification.Builder(this); builder.setSmallIcon(R.mipmap.ic_launcher); startForeground(NOTIFICATION_ID, builder.build()); new Handler().postDelayed(new Runnable() &#123; @Override public void run() &#123; stopForeground(true); NotificationManager manager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE); manager.cancel(NOTIFICATION_ID); stopSelf(); &#125; &#125;,100); &#125; &#125;&#125; 2.3、双进程守护 原理是A进程死的时候，B还在活着，B可以将A进程拉起来，反之，B进程死的时候，A还活着，A可以将B拉起来 在Android5.0以后，在应用退出后，ActivityManagerService不仅把主进程给杀死，另外把主进程所属的进程组一并杀死，这样一来，由于子进程和主进程在同一进程组，子进程在做的事情，也就停止了。所以在Android5.0以后双进程守护实现进程保活就不太可靠，要采用其他方案。 2.4、捆绑系统服务比如NotificationListenerService，NotificationListenerService就是一个监听通知的服务，只要手机收到了通知，NotificationListenerService都能监听到，即时用户把进程杀死，也能重启，所以说要是把这个服务放到我们的进程之中，就能实现进程保活了 2.5、相互唤醒相互唤醒的意思就是，假如你手机里装了支付宝、淘宝、天猫、UC等阿里系的app，那么你打开任意一个阿里系的app后，有可能就顺便把其他阿里系的app给唤醒了。这个完全有可能的。]]></content>
      <categories>
        <category>android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Fragment学习]]></title>
    <url>%2F2018%2F12%2F02%2FFragment%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[1、Fragment回退栈管理Activity是由任务栈管理的，遵循先进后出的原则，Fragment也可以实现类似的栈管理，从而实现多个Fragment先后添加后可以返回上一个Fragment，当activity容器内没有Fragment时回退则退出Activity。具体方法：FragmentTransaction.addToBackStack(String) // 通常传入null即可代码如下：123456Fragment f = new Fragment(); FragmentManager fm = getSupportFragmentManager(); FragmentTransaction ftx = fm.beginTransaction(); ftx.replace(R.id.fragment_container, f, &quot;tag&quot;); ftx.addToBackStack(null); ftx.commit(); 注：1.activity的第一个Fragment(根Fragment)可以不添加回退栈，这样最后一个Fragment按返回时就不会空白而是直接退出activity。2.调用addToBackStack(null)将当前的事务添加到了回退栈，调用replace方法后Fragment实例不会被销毁，但是视图层次会被销毁，即会调用onDestoryView和onCreateView。若需保存当前fragment视图状态，则可以使用hide后add新的Fragment 2、Fragment与Activity通信通用方式： Activity调用Fragment方法：如果Activity中包含自己管理的Fragment的引用，可以通过引用直接访问所有的Fragment的public方法Fragment调用Activity方法：在Fragment中可以通过getActivity得到当前绑定的Activity的实例，然后进行操作 推荐方式：1.接口（Fragment返回数据给Activity）Fragment部分代码：123456789101112131415161718192021public class TestFragment extends Fragment &#123; private OnSaveListener listener; public void setListener(OnSaveListener listener) &#123; this.listener = listener; &#125; public interface OnSaveListener &#123; void onSaveFinished(boolean result); void onSaveStart(); &#125; @OnClick(R.id.btn_save) public void save() &#123; .... listener.onSaveFinished(true); &#125;&#125; Activity部分代码：1234567891011121314151617TestFragment f = new TestFragment();f.setListener(new ShowCheckFragment.OnSaveListener() &#123; @Override public void onSaveFinished(boolean result) &#123; ...... &#125; @Override public void onSaveStart() &#123; ...... &#125;&#125;);FragmentTransaction fragmentTransaction = getSupportFragmentManager().beginTransaction(); fragmentTransaction.replace(R.id.fragment_container, f);fragmentTransaction.commit(); 2.Fragment Arguments（传递数据到Fragment中）Fragment部分代码：1234567891011121314151617181920212223242526272829ublic class TestFragment extends Fragment &#123; private String mArgument; public static final String ARGUMENT = &quot;argument&quot;; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); Bundle bundle = getArguments(); if (bundle != null) mArgument = bundle.getString(ARGUMENT); &#125; /** * 传入需要的参数，设置给arguments * @param argument * @return */ public static TestFragment newInstance(String argument) &#123; Bundle bundle = new Bundle(); bundle.putString(ARGUMENT, argument); TestFragment f = new TestFragment(); f.setArguments(bundle); return f; &#125; 3、Fragment重叠问题当屏幕旋转或者内存重启（Fragment以及容器activity被系统回收后再打开时重新初始化）会导致Fragment重叠问题，是因为activity本身重启的时候会恢复Fragment，然后创建Fragment的代码又会新建一个Fragment的原因。解决方法：在onCreate方法中判断参数Bundle savedInstanceState，为空时初始化Fragment实例，然后在Fragment中通过onSaveInstanceState的方法恢复数据Activity代码：12345678910111213141516171819202122private TestFragment f;protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Log.e(TAG, savedInstanceState+&quot;&quot;); if(savedInstanceState == null) &#123; f = new TestFragment(); FragmentManager fm = getSupportFragmentManager(); FragmentTransaction tx = fm.beginTransaction(); tx.add(R.id.id_content, f, &quot;ONE&quot;); tx.commit(); &#125; &#125;]]></content>
      <categories>
        <category>android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HashMap原理]]></title>
    <url>%2F2018%2F12%2F02%2FHashMap%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[图解HashMap(一) 笔记： HashMap是由数组和链表组合构成的数据结构，Java8中链表长度超过8时会把长度超过8的链表转化成红黑树；存取时都会根据键值计算出”类别”(hashCode)，再根据”类别”定位到数组中的位置并执行操作。 hashCode是一个对象的标识，Java中对象的hashCode是一个int类型值。通过hashCode来指定数组的索引可以快速定位到要找的对象在数组中的位置，之后再遍历链表找到对应值，理想情况下时间复杂度为O(1)，并且不同对象可以拥有相同的hashCode。 在数组大小不变的情况下，存放键值对越多，查找的时间效率会降低，扩容可以解决该问题，而负载因子决定了什么时候扩容，负载因子是已存键值对的数量和总的数组长度的比值。默认情况下负载因子为0.75，我们可在初始化HashMap的时候自己修改。 put(K key, V value) 主流程： 步骤①.根据键值key算出hash值 — &gt; hash(key) 步骤②.根据hash值和当前数组的长度计算在数组中的索引 — &gt; indexFor(hash, table.length) 步骤③情况1.hash值和key值都相同，替换原来的值，并将被替换的值返回。 步骤③情况2.坑位没人或发生hash碰撞 — &gt; addEntry(hash, key, value, i)]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java8新特性]]></title>
    <url>%2F2018%2F12%2F02%2FJava8%E6%96%B0%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[1、语言新特性1.1、Lambda表达式（也称闭包）Lambda表达式是Java8最大的卖点，它允许交函数作为参数传递给某个方法，或者把代码本身当成数据处理，在java8之前的版本中，只能用匿名内部类代替Lambda表达式。用-&gt;分隔函数形参和函数体， Arrays.asList( “a”, “b”, “d” ).forEach( e -&gt; System.out.println( e ) ); 如果函数体有多条语句，函数体花括号括起来 Arrays.asList( “a”, “b”, “d” ).forEach( e -&gt; { System.out.print( e ); System.out.print( e );} ); Lambda表达示有返回值，其类型和形参类型一样也是由编译器推测出来，如果函数体只有一条语句，则可以不用return，如 Arrays.asList( “a”, “b”, “d” ).sort( ( e1, e2 ) -&gt; e1.compareTo( e2 ) ); 1.2、接口的默认方法和静态方法默认方法使得开发者可以在 不破坏二进制兼容性的前提下，往现存接口中添加新的方法，即不强制那些实现了该接口的类也同时实现这个新加的方法。默认方法和抽象方法之间的区别在于抽象方法需要实现，而默认方法不需要。接口提供的默认方法会被接口的实现类继承或者覆写，例子代码如下：12345678910private interface Defaulable &#123; // Interfaces now allow default methods, the implementer may or // may not implement (override) them. default String notRequired() &#123; return &quot;Default implementation&quot;; &#125; &#125;private static class DefaultableImpl implements Defaulable &#123;&#125; 也可以添加实现123456private static class OverridableImpl implements Defaulable &#123; @Override public String notRequired() &#123; return &quot;Overridden implementation&quot;; &#125;&#125; Java 8带来的另一个有趣的特性是在接口中可以定义静态方法，例子代码如下：123456private interface DefaulableFactory &#123; // Interfaces now allow static methods static Defaulable create( Supplier&lt; Defaulable &gt; supplier ) &#123; return supplier.get(); &#125;&#125; 下面的代码片段整合了默认方法和静态方法的使用场景：1234567public static void main( String[] args ) &#123; Defaulable defaulable = DefaulableFactory.create( DefaultableImpl::new ); System.out.println( defaulable.notRequired() ); defaulable = DefaulableFactory.create( OverridableImpl::new ); System.out.println( defaulable.notRequired() );&#125; 1.3、方法引用第一种方法引用的类型是构造器引用，语法是Class::new，或者更一般的形式：Class::new。注意：这个构造器没有参数。12final Car car = Car.create( Car::new );final List&lt; Car &gt; cars = Arrays.asList( car ); 第二种方法引用的类型是静态方法引用，语法是Class::static_method。注意：这个方法接受一个Car类型的参数。1cars.forEach( Car::collide ); 第三种方法引用的类型是某个类的成员方法的引用，语法是Class::method，注意，这个方法没有定义入参：1cars.forEach( Car::repair ); 第四种方法引用的类型是某个实例对象的成员方法的引用，语法是instance::method。注意：这个方法接受一个Car类型的参数：12final Car police = Car.create( Car::new );cars.forEach( police::follow ); 1.4 重复注解自从Java 5中引入注解以来，这个特性开始变得非常流行，并在各个框架和项目中被广泛使用。不过，注解有一个很大的限制是：在同一个地方不能多次使用同一个注解。Java 8打破了这个限制，引入了重复注解的概念，允许在同一个地方多次使用同一个注解。 在Java 8中使用@Repeatable注解定义重复注解，实际上，这并不是语言层面的改进，而是编译器做的一个trick，底层的技术仍然相同]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[12306抢票流程]]></title>
    <url>%2F2018%2F12%2F02%2F12306%E6%8A%A2%E7%A5%A8%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[一、查票与站点页面 查询接口https://kyfw.12306.cn/otn/leftTicket/queryZ 二、登录页面 获取验证码https://kyfw.12306.cn/passport/captcha/captcha-image64 验证码校验https://kyfw.12306.cn/passport/captcha/captcha-check result_code==”4”校验成功 登陆接口https://kyfw.12306.cn/passport/web/login 获取newapptk值https://kyfw.12306.cn/passport/web/auth/uamtk 获取登陆成功后的cookie https://kyfw.12306.cn/otn/uamauthclient 三、下单流程 提交订单请求https://kyfw.12306.cn/otn/leftTicket/submitOrderRequest 获取globalRepeatSubmitToken和ticketInfoForPassengerForm https://kyfw.12306.cn/otn/confirmPassenger/initDc 获取乘客信息https://kyfw.12306.cn/otn/confirmPassenger/getPassengerDTOs 需要globalRepeatSubmitToken作为参数 检查订单 https://kyfw.12306.cn/otn/confirmPassenger/checkOrderInfo 获取余票和排队信息https://kyfw.12306.cn/otn/confirmPassenger/getQueueCount 订单确认 https://kyfw.12306.cn/otn/confirmPassenger/confirmSingleForQueue 成功后入队等待 轮询下单https://kyfw.12306.cn/otn/confirmPassenger/queryOrderWaitTime 查询订单是不是下单成功了https://kyfw.12306.cn/otn/confirmPassenger/resultOrderForDcQueue 获取订单详情 https://kyfw.12306.cn/otn/queryOrder/queryMyOrderNoComplete]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Selenium自动化的使用]]></title>
    <url>%2F2018%2F12%2F02%2FSelenium%E8%87%AA%E5%8A%A8%E5%8C%96%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1、准备下载chrome版本对就的对应的驱动chromedriver，放在python 安装目录下的Scripts目录下 2、安装seleniumpip install selenium 3、使用声明浏览器对象selenium支持很多浏览器，下面调用了Chrome浏览器，运行python 文件，将会打开Chrome浏览器123from selenium import webdriverbrowser = webdriver.Chrome() 访问页面打开百度页面12345from selenium import webdriverbrowser = webdriver.Chrome()browser.get(&quot;http://www.baidu.com&quot;) 查找元素单个元素查找查找元素的方法有12345678find_element_by_namefind_element_by_idfind_element_by_xpathfind_element_by_link_textfind_element_by_partial_link_textfind_element_by_tag_namefind_element_by_class_namefind_element_by_css_selector 123456789101112from selenium import webdriverbrowser = webdriver.Chrome()browser.get(&quot;http://www.baidu.com&quot;)su_id=browser.find_element_by_id(&apos;su&apos;)su_css=browser.find_element_by_css_selector(&quot;#su&quot;)su_xpath=browser.find_element_by_xpath(&quot;//*[@id=&apos;su&apos;]&quot;)print(su_id)print(su_css)print(su_xpath) 多元素查找同样的在单个元素中查找的方法在多个元素查找中同样存在：12345678find_elements_by_namefind_elements_by_idfind_elements_by_xpathfind_elements_by_link_textfind_elements_by_partial_link_textfind_elements_by_tag_namefind_elements_by_class_namefind_elements_by_css_selector 元素交互操作对获取到的元素调用交互方法1234567891011121314from selenium import webdriverimport timebrowser=webdriver.Chrome()browser.get(&quot;https://www.taobao.com&quot;)input=browser.find_element_by_id(&apos;q&apos;)input.send_keys(&quot;手机&quot;)time.sleep(10)input.clear()input.send_keys(&quot;小米&quot;)button=browser.find_element_by_class_name(&apos;btn-search&apos;)button.click()time.sleep(10)browser.close() 把动作附加到交互链中12345678910111213141516171819202122232425262728293031323334353637383940414243444546from selenium import webdriverfrom selenium.webdriver import ActionChainsimport timebrowser=webdriver.Chrome()# browser.get(&quot;https://www.taobao.com&quot;)# input=browser.find_element_by_id(&apos;q&apos;)# input.send_keys(&quot;手机&quot;)# time.sleep(10)# input.clear()# input.send_keys(&quot;小米&quot;)# button=browser.find_element_by_class_name(&apos;btn-search&apos;)# button.click()# time.sleep(10)# browser.close()url=&quot;http://www.runoob.com/try/try.php?filename=jqueryui-api-droppable&quot;browser.get(url)#切换到目标元素所在的framebrowser.switch_to_frame(&quot;iframeResult&quot;)#确定拖拽目标的起点source=browser.find_element_by_id(&quot;draggable&quot;)#确定拖拽目标的终点target=browser.find_element_by_id(&quot;droppable&quot;)#形成动作链actions=ActionChains(browser)actions.drag_and_drop(source,target)#执行actions.perform()&apos;&apos;&apos;1.先用switch_to_alert()方法切换到alert弹出框上2.可以用text方法获取弹出的文本 信息3.accept()点击确认按钮4.dismiss()相当于点右上角x，取消弹出框&apos;&apos;&apos;t=browser.switch_to_alert()print(t.text)time.sleep(2)t.accept()time.sleep(10)browser.close() 执行JavaScript可以直接调用js方法实现一些操作比如拖动页面、弹框显示123456from selenium import webdriverbrowser=webdriver.Chrome()browser.get(&quot;https://www.zhihu.com/explore&quot;)browser.execute_script(&quot;window.scrollTo(0,document.body.scrollHeight)&quot;)browser.execute_script(&quot;alert(&apos;To Button&apos;)&quot;)browser.close() 切换Frame通过switch_to.frame()和switch_to.parent_frame()进入和退出frame 等待当使用了隐式等待执行测试的时候，如果 WebDriver没有在 DOM中找到元素，将继续等待，超出设定时间后则抛出找不到元素的异常, 换句话说，当查找元素或元素并没有立即出现的时候，隐式等待将等待一段时间再查找 DOM，默认的时间是0 隐式等待到了一定的时间发现元素还没有加载，则继续等待我们指定的时间，如果超过了我们指定的时间还没有加载就会抛出异常，如果没有需要等待的时候就已经加载完毕就会立即执行1234567from selenium import webdriverbrowser = webdriver.Chrome()browser.implicitly_wait(10)browser.get(&apos;https://www.zhihu.com/explore&apos;)input = browser.find_element_by_class_name(&apos;zu-top-add-question&apos;)print(input) 浏览器的前进和后退back()forward() cookieget_cookies()delete_all_cookes()add_cookie() 选项卡操作通过执行js命令实现新开选项卡window.open()不同的选项卡是存在列表里browser.window_handles通过browser.window_handles[0]就可以操作第一个选项卡123456789101112import timefrom selenium import webdriverbrowser = webdriver.Chrome()browser.get(&apos;https://www.baidu.com&apos;)browser.execute_script(&apos;window.open()&apos;)print(browser.window_handles)browser.switch_to_window(browser.window_handles[1])browser.get(&apos;https://www.taobao.com&apos;)time.sleep(1)browser.switch_to_window(browser.window_handles[0])browser.get(&apos;https://python.org&apos;) 异常处理这里的异常比较复杂，这里只进行简单的演示，查找一个不存在的元素1234567891011121314from selenium import webdriverfrom selenium.common.exceptions import TimeoutException, NoSuchElementExceptionbrowser = webdriver.Chrome()try: browser.get(&apos;https://www.baidu.com&apos;)except TimeoutException: print(&apos;Time Out&apos;)try: browser.find_element_by_id(&apos;hello&apos;)except NoSuchElementException: print(&apos;No Element&apos;)finally: browser.close()]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Xposed应用的开发]]></title>
    <url>%2F2018%2F12%2F02%2FXposed%E5%BA%94%E7%94%A8%E7%9A%84%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[一. xposed原理Xposed的底层原理是通过替换/system/bin/app_precesss 程序控制zygote进程，使得它在系统启动的过程中会加载Xposed framework的一个jar文件即XposedBridge.jar，从而完成对Zygote进程及其创建的Dalvik虚拟机的劫持，并且能够允许开发者独立的替代任何class 二. 安装xposed框架 条件使用设备需要root 下载安装xposed框架的安装器安装器会自动检测和选择设备系统对应的xposed版本http://xposed.appkg.com/2303.html 安装xposed框架，目前的最新版本号是89，安装成功后重启设备 三. 首先创建一个需要被hook的目标应用新建一个应用XposedApplication目标：通过劫持方法~verifyLogin~ 返回登陆成功MainActivity123456789101112131415161718192021222324252627282930313233public class MainActivity extends AppCompatActivity &#123; private EditText etAccount; private EditText etPassword; private Button btnLogin; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); etAccount=findViewById(R.id.et_account); etPassword=findViewById(R.id.et_password); btnLogin=findViewById(R.id.btn_login); btnLogin.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; String account=etAccount.getText().toString(); String pwd=etPassword.getText().toString(); if(verifyLogin(account,pwd))&#123; Toast.makeText(MainActivity.this,&quot;登陆成功！&quot;,Toast.LENGTH_SHORT).show(); &#125;else &#123; Toast.makeText(MainActivity.this,&quot;登陆失败！&quot;,Toast.LENGTH_SHORT).show(); &#125; &#125; &#125;); &#125; private boolean verifyLogin(String account,String pwd)&#123; if(account.equals(&quot;leory&quot;)&amp;&amp;pwd.equals(&quot;123&quot;))&#123; return true; &#125; return false; &#125;&#125; R.layout.activity_main1234567891011121314151617181920212223LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; tools:context=&quot;com.zhuliyi.xposedapplication.MainActivity&quot;&gt; &lt;EditText android:id=&quot;@+id/et_account&quot; android:hint=&quot;账号&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; /&gt; &lt;EditText android:id=&quot;@+id/et_password&quot; android:hint=&quot;密码&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; /&gt; &lt;Button android:id=&quot;@+id/btn_login&quot; android:text=&quot;登陆&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; /&gt;&lt;/LinearLayout&gt; 四. 编写hook应用新建一个android工程XposedDemo 引入xposed api在app build.gradle文件中provided ‘de.robv.android.xposed:api:82’注意是通过provided方式引入 在AndroidManifest.xml文件配置xposed信息 12345678910111213&lt;!-- 标记xposed插件 start--&gt; &lt;meta-data android:name=&quot;xposedmodule&quot; android:value=&quot;true&quot;/&gt; &lt;!-- 模块描述 --&gt; &lt;meta-data android:name=&quot;xposeddescription&quot; android:value=&quot;测试Xposed&quot;/&gt; &lt;!-- 最低版本号 --&gt; &lt;meta-data android:name=&quot;xposedminversion&quot; android:value=&quot;54&quot;/&gt;&lt;!-- 标记xposed插件 end--&gt; 创建hook类，实现IXposedHookLoadPackage接口 1234567891011121314151617181920212223public class HelloHook implements IXposedHookLoadPackage &#123; @Override public void handleLoadPackage(XC_LoadPackage.LoadPackageParam lpparam) throws Throwable &#123; XposedBridge.log(&quot;===包名===&quot; + lpparam.packageName); if (lpparam.packageName.equals(&quot;com.zhuliyi.xposedapplication&quot;)) &#123; //混淆后方法名也变化了 XposedHelpers.findAndHookMethod(&quot;com.zhuliyi.xposedapplication.MainActivity&quot;, lpparam.classLoader, &quot;verifyLogin&quot;, String.class, String.class, new XC_MethodHook() &#123; @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123; super.beforeHookedMethod(param); &#125; @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123; super.afterHookedMethod(param); param.setResult(true); &#125; &#125;); &#125; &#125;&#125; handleLoadPackage方法回调是在目标应用加载时候调用，先通过LoadPackageParam参与判断目标应用的包名，然后通过XposedHelpers.findAndHookMethod() hook调用的方法，第一个参数是包名，第二个是classLoader,第三个是方法名，后面是方法参数，最后是XC_MethodHook回调，beforeHookedMethod是方法执行前调用 ，afterHookedMethod是方法执行后调用，通过param.setResult(true)，设置返回值为true,当然也可以通过进行其他操作，这里就不介绍了 添加hook文件配置我们需要在assets目录下面新建一个xposed_init文件，写上我们Hook文件的路径，如图: 接着 编译，运行，安装apk，最后在XposedInstaller 模块中添加XposedDemo框架，然后重启设置 随便输入都可以登陆成功 五.注意事项目前的应用大多是混淆的，这种 情况下，应用的属性和方法可能会被混淆，导致不是真实的方法名，比如我对目标应用进行混淆后，通过反编译工具查看到的代码如下图验证登陆的方法名verifyLogin变成了a，此时我们就要修改XposedHelpers.findAndHookMethod() 中的方法名为a 温馨提示：android反编译的工具为的详解地址]]></content>
      <categories>
        <category>android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[android前沿技术]]></title>
    <url>%2F2018%2F12%2F02%2Fandroid%E5%89%8D%E6%B2%BF%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[一、热升级Tinker源码解析与手写 二、热修复阿里云hotfix使用和原理 三、组件化组件化原理和ARouter组件化之路 四、RxJava响应式编程RxJava内核机制和原理解析 五、IOC注解ButterKnife和Dagger原理 六、Hook技术类加载原理Dex 文件结构反射]]></content>
      <categories>
        <category>android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[android单元测试]]></title>
    <url>%2F2018%2F12%2F02%2Fandroid%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[android基本的测试框架 java测试框架 Junit、Mockito。这两款测试框架用的比较普及，Junit用于测试方法有返回值的情况，没有返回值用Mockito，Junit只能用于Java代码，要想用于android代码，要用Mockito隔离依赖。 android测试框架 Robolectric、AndroidJUnitRunner、Espresso。AndroidJUnitRunner是Google官方的android单元测试框架之一，只能支行在Dalvik或ART，不能运行在JVM，所以只能运行在真机或模拟器。Robolectric运行在JVM上，速度快，不过不支持加载so,代码与没那么友好。Espresso也是Google官方的android单元测试框架之一，比较强大，测试代码简洁，运行在真机，所以没那么快 一. Junit 新建一个java文件Calculator，添加add方法12345public class Calculator &#123; public int add(int a ,int b)&#123; return a+b; &#125;&#125; 然后若键生成测试单元 AssertEquals的使用生成了CalculatorTest文件。在文件中添加测试的方法。123456789101112public class CalculatorTest &#123; Calculator calculator=new Calculator(); @Test public void testAdd() throws Exception &#123; int a=1; int b=2; int result=calculator.add(a,b); Assert.assertEquals(result,3); &#125;&#125; 用例中被@Test注释的方法，就可以单元进行单元测试。然后方法处右键run就可以运行 结果正确就显示 Process finished with exit code 0如果判断错误，比如改成Assert.assertEquals(result,3);则显示 二. Mockito三. Espresso]]></content>
      <categories>
        <category>android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[android开发细节]]></title>
    <url>%2F2018%2F12%2F02%2Fandroid%E5%BC%80%E5%8F%91%E7%BB%86%E8%8A%82%2F</url>
    <content type="text"><![CDATA[1、android:clipToPadding默认为true，当设置了padding时，滚动时内容不会绘制到padding区域。当设置了android:clipToPadding=false后内容滚动会绘制到padding区域 2、嵌套滚动NestedScrollView的用法和原理]]></content>
      <categories>
        <category>android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Activity Framework的说明]]></title>
    <url>%2F2018%2F12%2F02%2FActivity%20Framework%E7%9A%84%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[ActivityManagerServices，简称AMS，服务端对象，负责系统中所有Activity的生命周期 ActivityThread，App的真正入口。当开启App之后，会调用main()开始运行，开启消息循环队列，这就是传说中的UI线程或者叫主线程。与ActivityManagerServices配合，一起完成Activity的管理工作 ApplicationThread，用来实现ActivityManagerService与ActivityThread之间的交互。在ActivityManagerService需要管理相关Application中的Activity的生命周期时，通过ApplicationThread的代理对象与ActivityThread通讯。 ApplicationThreadProxy，是ApplicationThread在服务器端的代理，负责和客户端的ApplicationThread通讯。AMS就是通过该代理与ActivityThread进行通信的。 Instrumentation，每一个应用程序只有一个Instrumentation对象，每个Activity内都有一个对该对象的引用。Instrumentation可以理解为应用进程的管家，ActivityThread要创建或暂停某个Activity时，都需要通过Instrumentation来进行具体的操作。 ActivityStack，Activity在AMS的栈管理，用来记录已经启动的Activity的先后关系，状态信息等。通过ActivityStack决定是否需要启动新的进程。 ActivityRecord，ActivityStack的管理对象，每个Activity在AMS对应一个ActivityRecord，来记录Activity的状态以及其他的管理信息。其实就是服务器端的Activity对象的映像。 TaskRecord，AMS抽象出来的一个“任务”的概念，是记录ActivityRecord的栈，一个“Task”包含若干个ActivityRecord。AMS用TaskRecord确保Activity启动和退出的顺序。如果你清楚Activity的4种launchMode，那么对这个概念应该不陌生。]]></content>
      <categories>
        <category>android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ANR]]></title>
    <url>%2F2018%2F12%2F02%2FANR%2F</url>
    <content type="text"><![CDATA[1、ANR是什么ANR(Application Not Responding)，即程序未响应，如果一个应用无法响应用户的输入，系统会弹出一个无响应的对话框，这个就是ANR. 2、出现的场景 InputDispatching Timeout：5秒内无法响应屏幕触摸事件或键盘输入事件 BroadcastQueue Timeout ：在执行前台广播（BroadcastReceiver）的onReceive()函数时10秒没有处理完成，后台为60秒 Service Timeout ：前台服务20秒内，后台服务在200秒内没有执行完毕。 ContentProvider Timeout ：ContentProvider的publish在10s内没进行完。 3、如何避免 尽量避免在UI线程中执行耗时的任务]]></content>
      <categories>
        <category>android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java集合]]></title>
    <url>%2F2018%2F12%2F02%2Fjava%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[java集合定义在java.util中 通过上面的接口框架图可以看出：Collection和Map&lt;K,V&gt;是java.util框架中的两个根接口，代表了两种不同的数据结构：集合和映射表。 Collection可以用iterator()迭代器到迭代集合，也可以使用“for each”来遍历，效果和使用iterator一样而List、Set则是继承自Collection下最核心的两个接口，List有序并可以通过整数索引来访问，Set不可重复 Map&lt;K,V&gt;从键映射到值的一个对象，键不能重复，每个键至多映射到一个值，从键不能重复这个特点用Set来实现TreeMap是有序的，效率比 HashMap 低HashMap是无序的，速度很快LinkedHashMap，结合两者的特点，有序不过没HashMap 快 List：特性:有序。ArrayList 基于数组；LinkedList 基于双向链表Set：特性:不可重复。TreeSet 有顺序，HashSet高效，LinkedHashSet 有序也快的SetMap：映射集合。key是set,value是collection，HashMap的key对应的是HashSet，TreeHash的key对应的是TreeSet，LinkedHashMap的key对应的key是LinkedHashSet.]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python 爬虫百度图片之列表图]]></title>
    <url>%2F2018%2F12%2F02%2Fpython%20%E7%88%AC%E8%99%AB%E7%99%BE%E5%BA%A6%E5%9B%BE%E7%89%87%E4%B9%8B%E5%88%97%E8%A1%A8%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[一、爬虫准备语言：python浏览器：google chrome工具：request模块 首先我们在百度图片搜索页面输入需要搜索的关键词（比如：明星）页面结果如下按F12进入开者，随便检查列表一张图片 可以看到找到图片的地址，copy src里面的图片地址https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=371978350,138525231&amp;fm=26&amp;gp=0.jpg，待用 选择Network All ，刷新一下页面，看到和浏览器一样的请求，类型为document 这个就是浏览器返回的页面，点击这个请求，并cont+f查找刚才复制的图片地址，可以发现能在js代码中找到该图片地址，也就是这个页面的图片地址不是静态页面生成的，是js动态生成的。这样不能通过request.get(url)审查元素获取图片地址，不过也可以通过正则表达式来获取js代码里面的图片地址，这样方式我不推荐 那么，图片地址是在那里获取的呢，切换Netword下的All标签到XHR，我们可以看到这个请求 ，打开一看https://image.baidu.com/search/acjson?tn=resultjson_com&amp;ipn=rj&amp;ct=201326592&amp;is=&amp;fp=result&amp;queryWord=%E6%98%8E%E6%98%9F&amp;cl=2&amp;lm=-1&amp;ie=utf-8&amp;oe=utf-8&amp;adpicid=&amp;st=-1&amp;z=&amp;ic=&amp;hd=&amp;latest=&amp;copyright=&amp;word=%E6%98%8E%E6%98%9F&amp;s=&amp;se=&amp;tab=&amp;width=&amp;height=&amp;face=0&amp;istype=2&amp;qc=&amp;nc=1&amp;fr=&amp;expermode=&amp;force=&amp;pn=30&amp;rn=30&amp;gsm=1e&amp;1552975216767= 这个好像就是我们想要的列表数据，打开一看，确定是，获取，这样我们可以通过请求上面的地址，获取我们想要的数据，仔细看看地址的参数queryWord、word是我们编码的搜索关键字，不用编码也没问题，rn是每一页的图片数，默认30，pn是第几个图片,通常rn的倍数，其他的参数都是固定了，只需要改变这三个参数来获取列表图片了。 注意事项有些图片地址直接复制到浏览器上是请求不到图片的，也就是requsts.get(image_url)是获取不到图片的，后来查找到浏览器正常的操作是有带有头部Referer，指向搜索地址 python 代码实现如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import requestsimport reimport timeimport osimport urllib.parseimport jsonpage_num=30photo_dir=&quot;D:\\data\\pic\\face\\photo&quot;def getThumbImage(word): num=0 url = &quot;http://image.baidu.com/search/flip?tn=baiduimage&amp;ie=utf-8&amp;word=&#123;0&#125;&amp;pn=&#123;1&#125;&quot; while num&lt;50: page_url=url.format(urllib.parse.quote(word),num*page_num) print(page_url) response=requests.get(page_url) pic_urls=re.findall(&apos;&quot;thumbURL&quot;:&quot;(.*?)&quot;,&apos;,response.text,re.S) if pic_urls: for pic_url in pic_urls: name=pic_url.split(&apos;/&apos;)[-1] print(pic_url) headers=&#123; &quot;Referer&quot;:page_url, &#125; html=requests.get(pic_url,headers=headers) with open(os.path.join(word_dir,name),&apos;wb&apos;)as f: f.write(html.content) num=num+1def getThumb2Image(word): num=0 url = &quot;https://image.baidu.com/search/acjson?tn=resultjson_com&amp;ipn=rj&amp;ct=201326592&amp;is=&amp;fp=result&amp;queryWord=&#123;0&#125;&amp;cl=2&amp;lm=-1&amp;ie=utf-8&amp;oe=utf-8&amp;adpicid=&amp;st=-1&amp;z=&amp;ic=&amp;hd=&amp;latest=&amp;copyright=&amp;word=&#123;0&#125;&amp;s=&amp;se=&amp;tab=&amp;width=&amp;height=&amp;face=0&amp;istype=2&amp;qc=&amp;nc=1&amp;fr=&amp;expermode=&amp;force=&amp;pn=&#123;1&#125;&amp;rn=&quot;+str(page_num)+&quot;&amp;gsm=1e&amp;1552975216767=&quot; while num&lt;50: page_url=url.format(urllib.parse.quote(word),num*page_num) print(page_url) response=requests.get(page_url) pic_urls=re.findall(&apos;&quot;thumbURL&quot;:&quot;(.*?)&quot;,&apos;,response.text,re.S) for pic_url in pic_urls: name=pic_url.split(&apos;/&apos;)[-1] print(pic_url) headers=&#123; &quot;Referer&quot;:page_url, &#125; html=requests.get(pic_url,headers=headers) with open(os.path.join(word_dir,name),&apos;wb&apos;)as f: f.write(html.content) num=num+1 if __name__ == &quot;__main__&quot;: word = input(&quot;请输入搜索关键词(可以是人名，地名等): &quot;) word_dir=os.path.join(photo_dir,word) if not os.path.exists(word_dir): os.mkdir(word_dir) getThumb2Image(word)]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python 爬虫百度图片之详情大图]]></title>
    <url>%2F2018%2F12%2F02%2Fpython%20%E7%88%AC%E8%99%AB%E7%99%BE%E5%BA%A6%E5%9B%BE%E7%89%87%E4%B9%8B%E8%AF%A6%E6%83%85%E5%A4%A7%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[上次我们学会了怎么样爬取百度的列表图片，速度很快，但是我觉得不满意，因为爬取的列表图片都只是缩略图片，点击进入详情才是高清图片。于是我继续探索。 实现的步骤点击列表图片，进入详情页面，我们可以获取详情页的请求地址是https://image.baidu.com/search/detail?ct=503316480&amp;z=0&amp;ipn=d&amp;word=%E6%98%8E%E6%98%9F&amp;step_word=&amp;hs=0&amp;pn=2&amp;spn=0&amp;di=6752966330&amp;pi=0&amp;rn=1&amp;tn=baiduimagedetail&amp;is=0%2C0&amp;istype=2&amp;ie=utf-8&amp;oe=utf-8&amp;in=&amp;cl=2&amp;lm=-1&amp;st=-1&amp;cs=371978350%2C138525231&amp;os=3779051497%2C2039068748&amp;simid=0%2C0&amp;adpicid=0&amp;lpn=0&amp;ln=1785&amp;fr=&amp;fmq=1552974833622_R&amp;fm=result&amp;ic=&amp;s=undefined&amp;hd=&amp;latest=&amp;copyright=&amp;se=&amp;sme=&amp;tab=0&amp;width=&amp;height=&amp;face=undefined&amp;ist=&amp;jit=&amp;cg=&amp;bdtype=0&amp;oriquery=&amp;objurl=http%3A%2F%2Fimg.zcool.cn%2Fcommunity%2F015abf5a92a96aa801219231c32adc.jpg%401280w_1l_2o_100sh.jpg&amp;fromurl=ippr_z2C%24qAzdH3FAzdH3Fooo_z%26e3Bzv55s_z%26e3Bv54_z%26e3BvgAzdH3Fo56hAzdH3FZM3YyMTIdMTI%3D_z%26e3Bip4s&amp;gsm=0&amp;rpstart=0&amp;rpnum=0&amp;islist=&amp;querylist=&amp;force=undefined又臭又长， 这个地址不能直接获取，也是动态生成的。可以发现一些参数可以在列表图片的数据中获取，列表图片的数据如下，这样把对应的数据填上就可以了，经过我测试发现只有几个参数是必要的。 检查图片，复制图片地址 进入Network -&gt; All，第一个就是详情页请求的响应， ctrl+f查找刚才复制的地址，注意，地址可能不是完全一致，如果找不到可以删除一些参数再找一下，最后发现图片地址也可以在js代码中找到， 这样获取详情页面响应后，可以正则匹配或者解析html要查找图片的地址。这样可以就可以下载百度高清大图了 实现的代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import requestsimport reimport timeimport osimport urllib.parsefrom lxml import etreeimport jsonpage_num=30photo_dir=&quot;D:\\data\\pic\\face\\photo&quot;def getDetailImage(word): num=0 url = &quot;https://image.baidu.com/search/acjson?tn=resultjson_com&amp;ipn=rj&amp;ct=201326592&amp;is=&amp;fp=result&amp;queryWord=&#123;0&#125;&amp;cl=2&amp;lm=-1&amp;ie=utf-8&amp;oe=utf-8&amp;adpicid=&amp;st=-1&amp;z=&amp;ic=&amp;hd=&amp;latest=&amp;copyright=&amp;word=&#123;0&#125;&amp;s=&amp;se=&amp;tab=&amp;width=&amp;height=&amp;face=0&amp;istype=2&amp;qc=&amp;nc=1&amp;fr=&amp;expermode=&amp;force=&amp;pn=&#123;1&#125;&amp;rn=&quot;+str(page_num)+&quot;&amp;gsm=1e&amp;1552975216767=&quot; while num&lt;50: page_url=url.format(urllib.parse.quote(word),num*page_num) print(page_url) response=requests.get(page_url) regex = re.compile(r&apos;\\(?![/u&quot;])&apos;) json_data=json.loads(regex.sub(r&quot;\\\\&quot;, response.text))#问题在于编码中是\xa0之类的，当遇到有些 不用转义的\http之类的，则会出现以上错误 for item in json_data[&apos;data&apos;]: try : params=&#123; &quot;word&quot;:word, &quot;di&quot;:item[&apos;di&apos;], &quot;tn&quot;:&quot;baiduimagedetail&quot;, &quot;cs&quot;:item[&apos;cs&apos;], &quot;os&quot;:item[&apos;os&apos;], &#125; detail_url=&quot;http://image.baidu.com/search/detail&quot; response=requests.get(detail_url,params=params) selector = etree.HTML(response.text) pic_url=selector.xpath(&quot;//img[@id=&apos;hdFirstImgObj&apos;]/@src&quot;)[0] print(pic_url) name=pic_url.split(&apos;/&apos;)[-1] headers=&#123; &quot;Referer&quot;:page_url, &#125; html=requests.get(pic_url,headers=headers) with open(os.path.join(word_dir,name),&apos;wb&apos;)as f: f.write(html.content) except: pass num=num+1 if __name__ == &quot;__main__&quot;: word = input(&quot;请输入搜索关键词(可以是人名，地名等): &quot;) word_dir=os.path.join(photo_dir,word) if not os.path.exists(word_dir): os.mkdir(word_dir) getDetailImage(word)]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python爬取bing图片高清详情图片]]></title>
    <url>%2F2018%2F12%2F02%2Fpython%E7%88%AC%E5%8F%96bing%E5%9B%BE%E7%89%87%E9%AB%98%E6%B8%85%E8%AF%A6%E6%83%85%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[首先我们看一下列表图片输入搜索关键词，搜索，检查列表图片，我们可以看到有些图片是url地址，有些图片是base64加密后编码，如果我们想获取列表图片，就要判断图片地址是正常的地址或者是base64编码后的图片数据 好了，进入正题，点击图片进入图片详情，检查一下详情图 复制地址http://pic4.bbzhi.com/mingxingbizhi/gaoqingxingganmingxingmeinvbizhi/gaoqingxingganmingxingmeinvbizhi_492447_11.jpg，待用 然后查看Network下的XHR ，我们可以看到有一个请求地址为 https://cn.bing.com/images/api/custom/search?q=%e6%98%8e%e6%98%9f&amp;id=5346B1F09BDF83A8071CA1207E464A5A2854EE9F&amp;preserveIdOrder=1&amp;count=25&amp;offset=10&amp;skey=i2Izp8J5wgHAdHaOFu23wImzazaPIObVo4It5nAMLDY&amp;safeSearch=Strict&amp;IG=4CEECBADC5044BBA92769CE4B1564230&amp;IID=idpfs&amp;SFX=1 点击看一下响应，好像发现了新大陆， 这里有一个value的列表，就是我们想要的图片列表，而且通过查找我们发现contentUrl就是我们想要的详情地址，这样一举二得。 我们看一下这个url的构成，参数q就是搜索编码后的关键词，不编码也没问题，count是每页图片的数量，默认25，offset是偏移量，从0开始，通常count的倍数，其他参数无须变化，只需要修改三个参数就可以获取想要的高清图片了。]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[volatile和Synchronized关键字说明]]></title>
    <url>%2F2018%2F12%2F02%2Fvolatile%E5%92%8CSynchronized%E5%85%B3%E9%94%AE%E5%AD%97%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[一、volatile修饰共享变量，保证变量的可见性和有序性，不保证原子性 保证可见性线程A在工作内存中修改的共享属性值会立即刷新到主存，线程B/C/D每次通过读写栅栏来达到类似于直接从主存中读取属性值 保证有序性重排序时，以volatile修饰属性的读/写操作代码行为分界线，读/写操作前面的代码不许排序到后面，后面同理不许排序到前面。由此保证有序性 不保证原子性如果volatile修饰的属性若在修改前已读取了值，那么修改后，无法改变已经复制到工作内存的值 二、Synchronized保证同一时刻最多只有1个线程执行 被Synchronized修饰的方法 / 代码 对象锁作用于对像的方法或代码块 类锁作用于静态方法或静态代码块]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用 mitmproxy + python 做拦截代理]]></title>
    <url>%2F2018%2F12%2F02%2F%E4%BD%BF%E7%94%A8%20mitmproxy%20%2B%20python%20%E5%81%9A%E6%8B%A6%E6%88%AA%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[前提：安装mitmproxy pip install mitmproxy 第一步：以代理方式启动chrome:cmd 然后 “C:\Program Files (x86)\Google\Chrome\Application\chrome.exe” –proxy-server=127.0.0.1:8080 –ignore-certificate-errors 第二步：编写脚本 第三步：启动mitmproxy mitmweb，并且可以在浏览器http://127.0.0.1:8081/查看拦截]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[启动模式]]></title>
    <url>%2F2018%2F12%2F02%2F%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[1、Android进阶系列之启动模式 2、Android 深入解析 Activity 的 launchMode 启动模式，Intent Flag，taskAffinity 心得 ： A activity 启动B activity （activity默认askAffinity为包名） 当B的启动模式为singleTask或singleInstance时，则启动B taskAffinity 所在的栈 当B的启动模式为standard或singleTop时，则启动与A taskAffinity 所在的栈 intent flag: FLAG_ACTIVITY_CLEAR_TASK 该标志必须和FLAG_ACTIVITY_NEW_TASK一起使用。 FLAG_ACTIVITY_CLEAR_TOP A-&gt;B-&gt;C C 启动A 的intent带有FLAG_ACTIVITY_CLEAR_TOP ，A,B,C 销毁，A会重新启动，如果intent还带有FLAG_ACTIVITY_SINGLE_TOP，A就不会销毁 FLAG_ACTIVITY_NEW_TASK A以FLAG_ACTIVITY_NEW_TASK 启动B 如果B是主栈 （mainactivity所在的栈），则与standard模式一样；如果B是次栈，则启动B taskAffinity所在的栈，栈里面的顺序不变 FLAG_ACTIVITY_NO_HISTORY 一离开就会被销毁 FLAG_ACTIVITY_NEW_DOCUMENT 如果找到B存在，则调用B所在的栈操作，如果B不存在，则打开新的栈放在新的任务列表里]]></content>
      <categories>
        <category>android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[图片在不同文件夹drawable 不同手机屏幕分辨率大小]]></title>
    <url>%2F2018%2F12%2F02%2F%E5%9B%BE%E7%89%87%E5%9C%A8%E4%B8%8D%E5%90%8C%E6%96%87%E4%BB%B6%E5%A4%B9drawable%20%E4%B8%8D%E5%90%8C%E6%89%8B%E6%9C%BA%E5%B1%8F%E5%B9%95%E5%88%86%E8%BE%A8%E7%8E%87%E5%A4%A7%E5%B0%8F%2F</url>
    <content type="text"><![CDATA[android资源目录下的各个drawable文件类对应的屏幕密度比较 android 根据名称来寻找图片时，首先查找与手机真实屏幕ppi的drawable文件夹,比如说我的手机ppi为320,就会在drawable-xhdpi(dpi=320)中查找图片，如果找不到，就会在就近的drawable文件夹中查找，以此类推，直到在drawable目录下找到图片。 如果在drawable-xhdpi中找到了图片，则获取的图片的长宽就等于图片的真实大小，如果在drawable-mdpi中找到了图片，则获取的图片的长宽就等于真实图片的2倍，如果在drawable-xxhdpi中找到图片，则获取的图片的长宽就等于真实图片的2/3倍. 结论 一、同一个手机，如果图片从高分辨文件夹移到低分辨率文件夹，图片长宽变大，占用的内存变大；如果图片从低辨文件夹移到高分辨率文件夹，图片长宽变小，占用的内存变小。 二、图片放在同一个文件夹，如果真实手机ppi比图片文件夹对应的dpi低，则图片的长宽会变小，占用的内存也会变小；如果真实手机ppi比图片文件夹对应的dpi高，则图片的长宽会变大，占用的内存也会变大。]]></content>
      <categories>
        <category>android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[如果使用hexo在github上搭建自己的博客]]></title>
    <url>%2F2018%2F12%2F02%2F%E5%A6%82%E6%9E%9C%E4%BD%BF%E7%94%A8hexo%E5%9C%A8github%E4%B8%8A%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[目前的写技术的文章的工具比较多，比如简书，掘金等第三方写作平台，用起来比较方便，那为什么还要搭建自己的博客呢，因为作为开发者没有个人的博客都显示不“了高逼格”，而且第三方写作平台主题都是定制好，自由性不好。个人博客工具之前用的比较多的wordpress，到现在的hexo，越来越简洁易用，下面直接说说今天的主角hexo以及怎么得用hexo搭建开发的个人博客。 hexo是什么hexo可以理解成是基于node.js制作的一个博客工具，hexo不需要部署到我们的服务器上，我们能能markdown编辑markdown文章，然后hexo帮我们生成静态的html页面，然后交生成的html文件上传到服务器上，hexo就是一个静态页面生成、上传的工具。 环境 git 下载安装git客户端 Node.js 下载安装Node.js Github账号 注册github帐号，Repository name为”自己的名称+.github.io”，然后创建。 配置github的ssh密码 首先在本地生成ssh密码，首先在桌面空白处鼠标右键选择Git Bash Here，然后输入：1ssh-keygen -t rsa -C &quot;your&apos;s emaill address&quot; 其中your’s emaill address填入你的邮箱地址，回车，会提示你文件保存的路径，回车确认，然后输入github密码，输入确定，这时会生成两个文件，一个是id_rsa，另一个是id_rsa.pub，打开id_rsa.pub，复制里面的全部内容 登陆github,点击头像，选择SSH and GPG keys,选择New SSH key输入title名称，自定义，把上面复制的Key粘贴到Key里面，点击Add SSH key，添加成功 安装Hexo打开命令行，输入1npm install -g hexo-cli 等待一段时间后安装成功，通过hexo -v测试是否安装成功创建一个空文件夹，如blog，存放博客信息，然后通过命令行进入该目录下，依次输入执行以下命令1234hexo initnpm installhexo ghexo s 这时在浏览器输入http://localhost:4000/就看到本地成功的博客页面了 配置Hexo到Github找到我们刚刚创建的博客文件夹，打到_config.yml文件，打开修改最后的成下面的样子 1234deploy: type: git repository: https://github.com/yourname/yourname.github.io.git branch: master 注意yourname是你github的用户名保存后执行,生成和上传静态页面到github123hexo cleanhexo ghexo d 注：如果出现如下异常1ERROR Deployer not found: git 需要1npm install hexo-deployer-git --save 这样你的博客地址就是https://yourname.github.io了]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[机器学习算法]]></title>
    <url>%2F2018%2F12%2F02%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[机器学习的算法分监督算法和无监督 算法。监督算法包括回归算法，神经网络，SVM；无监督算法包括聚类算法，降维算法。 一、回归算法分线性回归和逻辑回归。线性回归预测的结果是线性数值，逻辑回归预测的结果是离散分类数值，线性回归用一般使用“最小二乘法”来求解,最后转化成求极值，数学上是用求导数0，不过计算机干不了，计算机用梯度下降法来求极值。 二、神经网络(也称之为人工神经网络，ANN)分成输入层、隐藏层、输出层。输入层负责接收信号，隐藏层负责对数据的分解与处理，最后的结果被整合到输出层。每个层由数个处理单元组成，若干个层再组成网络，即神经网络。每个处理单元事实上就是一个逻辑回归模型。例子LeNet手写数字识别。 深度学习，即多隐藏层的神经网络 三、SVM（支持向量机）诞生于统计学，是逻辑回归算法的强化。最典型的特征就是可以将低维的空间映射到高维的空间，比如非线性二维平面分界可以映射到线性三维空间中。 四、聚类算法训练数据都是不含标签的，而算法的目的则是通过训练，推测出这些数据的标签。聚类算法是无监督算法中的最典型的代表。而聚类算法中最典型的代表就是K-Means算法。 五、降维算法顾名思义就是将数据从高维降到低维。维度是特征的数量。降维算法能去掉数据冗余，降维算法的主要作用是压缩数据与提升机器学习其他算法的效率，通过降维算法，可以将具有几千个特征的数据压缩至若干个特征，PCA算法(即主成分分析算法) 六、推荐算法一类是基于物品内容推荐，另一类是根据用户相似度推荐，一般两者混合使用。比较有名的算法是协同过滤算法。 七、其他算法如高斯判别、朴素贝叶斯、决策树等算法。]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2018%2F12%2F02%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[python 正则使用方法re.match re.match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败 re.search re.search匹配整个字符串，直到找到一个匹配 findall 在字符串中找到正则表达式所匹配的所有子串，并返回一个列表，如果没有找到匹配的，则返回空列表。注意： match 和 search 是匹配一次 findall 匹配所有。 正则表达式的匹配字符的匹配 . : 匹配任意1个字符(除了\n)[] :匹配[]中列举的字符\d :匹配数字,也就是0-9\D:匹配非数字,也就是匹配不是数字的字符\s :匹配空白符,也就是 空格\tab\S:匹配非空白符,\s取反\w:匹配单词字符, a-z, A-Z, 0-9, _\W:匹配非单词字符, \w取反 数量的匹配 *匹配前一个字符出现0次多次或者无限次,可有可无，可多可少+:匹配前一个字符出现1次多次或则无限次,直到出现一次?:匹配前一个字符出现1次或者0次,要么有1次,要么没有{m}:匹配前一个字符出现m次{m,n}:匹配前一个字符出现m到n次 边界的匹配 ^:匹配字符串开头$:匹配字符串结尾\b:匹配一个单词的边界\B:匹配非单词边界 匹配分组 |:或匹配(ab):将括号中字符作为一个分组]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[类加载的原理]]></title>
    <url>%2F2018%2F12%2F02%2F%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[Java类加载器类加载器可以分为三类： 启动类加载器（Bootstrap ClassLoader）：负责加载\lib目录下或者被-Xbootclasspath参数所指定的路径的，并且是被虚拟机所识别的库到内存中。 扩展类加载器（Extension ClassLoader）：负责加载\lib\ext目录下或者被java.ext.dirs系统变量所指定的路径的所有类库到内存中。 应用类加载器（Application ClassLoader）：负责加载用户类路径上的指定类库，如果应用程序中没有实现自己的类加载器，一般就是这个类加载器去加载应用程序中的类库。 类加载器的双亲委派模型，原理如下： 如果一个类加载器收到了加载类的请求，它不会自己立即去加载类，它会先去请求父类加载器，每个层次的类加载器都是如此。层层传递，直到传递到最高层的类加载器，只有当 父类加载器反馈自己无法加载这个类，才会有当前子类加载器去加载该类 流程图如下 类加载器的双亲委派模型 Android虚拟机类加载机制Java虚拟机加载的是class文件，而Android虚拟机加载的是dex文件（多个class文件合并而成）Android类加载器类图如下所示： Android类加载器类图可以看到Android类加载器的基类是BaseDexClassLoader，它有派生出两个子类加载器： PathClassLoader: 主要用于系统和app的类加载器,其中optimizedDirectory为null, 采用默认目录/data/dalvik-cache/ DexClassLoader: 可以从包含classes.dex的jar或者apk中，加载类的类加载器, 可用于执行动态加载, 但必须是app私有可写目录来缓存odex文件. 能够加载系统没有安装的apk或者jar文件， 参考： Android虚拟机框架：类加载机制]]></content>
      <categories>
        <category>android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[设计模式之单例模式]]></title>
    <url>%2F2018%2F12%2F02%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[什么是设计模式？其实简单的理解就是前人留下来的一些经验总结 一、懒汉式懒汉式的特点就是在getInstance()方法时候才进行初始化1234567891011public class Singleton &#123; private static Singleton instance; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 这种单列模式在线程并发时候就可能会产生多个实例，称为线程不安全 二、懒汉式（线程安全）1234567891011public class Singleton &#123; private static Singleton instance; private Singleton() &#123; &#125; public static synchronized Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 可以看出加入同步关键字synchronized这样实现了线程的安全，但是每次调用都会实现同步，导致效果很低 ##三、双重检测机制123456789101112131415161718public class Singleton &#123; private static Singleton instance; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; if(instance==null)&#123; synchronized (Singleton.class) &#123; if (instance == null) &#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; 二次检查实例是否创建，第一次检查没有创建，进行同步，同步后第二次检查，这种方法看似很完美，不过也有缺点，在于instance = new Singleton();这条语句，新建对象包含了下面三个步骤：1、分配内存2、执行构造方法的初始化3、将对象指向分配的内存空间 由于java编译器为了尽可能减少内存操作速度远慢于CPU运行速度所带来的CPU空置的影响，虚拟机会按照自己的一些规则将程序编写顺序打乱——即写在后面的代码在时间顺序上可能会先执行，而写在前面的代码会后执行——以尽可能充分地利用CPU就会出现指令重排序(happen-before)，从而导致上面的三个步骤执行顺序发生改变。正常情况下是123，但是如果指令重排后执行为1,3,2那么久会导致instance 为空，进而导致程序出现问题。解决方法呢？java中有一个关键字volatile，有一个作用就是防止指令重排。 private static Singleton instance; 饿汉式饿汉式的特点就是在类加载的时候就进行初始化操作12345678910public class Singleton&#123; private static final Singleton instance = new Singleton(); private Singleton() &#123; &#125; public static Singleton getInstance()&#123; return instance; &#125;&#125; 与懒汉式相比，它是线程安全的，无需用同步关键字修饰优点就是由于没有加锁，执行效率比较高缺点就是在类加载时就初始化，会浪费内存 ##]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[设计模式之工厂模式]]></title>
    <url>%2F2018%2F12%2F02%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[工厂模式包括简单工厂模式、工厂方法模式、抽象工厂模式。工厂模式形式和特点都很相似，他们最终的目的都是为了解耦。 简单工厂模式 定义：专门定义一个类用来创建其他类的实例，被创建的实例通常都具有共同的父类。 例如有客户要选择两个品牌的手机，小米和华为，这时候客户只需要把选择type交给Factory，Factory根据type来创建各品牌手机的实例。简单工厂java代码实现如下123456789101112131415161718192021222324252627282930313233343536373839404142434445interface Phone&#123; public void printPhone();&#125;public class XiaoMiPhone implements Phone &#123; @Override public void printPhone() &#123; System.out.println(&quot;This is a XiaoMi Phone&quot;); &#125;&#125;public class HuaWeiPhone implements Phone &#123; @Override public void printPhone() &#123; System.out.println(&quot;This is a HuaWei Phone&quot;); &#125;&#125;public class PhoneFactory &#123; public Phone createPhone(String type) &#123; Phone p = null; if(type.equals(&quot;xiaomi&quot;)) &#123; p = new XiaoMiPhone (); &#125;else if(type.equals(&quot;huawei&quot;)) &#123; p = new HuaWeiPhone (); &#125; return p; &#125;&#125;public class Client &#123; public void buy(Phone p)&#123; System.out.println(&quot;I buy a phone&quot;); p.printComputer(); &#125; public static void main(String[] args) &#123; Client c = new Client(); PhoneFactory pf = new PhoneFactory (); Phone p= pf .createPhone(&quot;xiaomi&quot;); c.buy(p); &#125;&#125; 但是问题来了如果，如果客户来选择其他手机品牌MeiZu，就需要修改工厂类PhoneFactory r 代码，添加type为meizu的品牌。违反了对扩展开放，对修改关闭的原则，即“开闭原则” 开闭原则：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭 所以简单工厂模式的优缺点：优点：工厂Factory负责产生具体的实例对象 ，实现具体的逻辑，通过客户的输入就可以得到具体的实例，客户不需要知道各类型实例的具体实现，交给工厂即可。缺点：违反了“开闭原则”。 针对简单工厂模式的缺点，我们需要改良工厂模式，这就出现了工厂方法模式。 工厂方法模式 定义：定义一个用来创建对象的接口，让子类决定实例化哪一个类，让子类决定实例化延迟到子类。 实现方式与简单工厂模式的区别是，把之前的PhoneFactory抽象成一个接口，每一个手机品牌都有一个对应的PhoneFactory的实现类。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051interface Phone&#123; public void printPhone();&#125;public class XiaoMiPhone implements Phone &#123; @Override public void printPhone() &#123; System.out.println(&quot;This is a XiaoMi Phone&quot;); &#125;&#125;public class HuaWeiPhone implements Phone &#123; @Override public void printPhone() &#123; System.out.println(&quot;This is a HuaWei Phone&quot;); &#125;&#125;public interface PhoneFactory &#123; public Phone createPhone();&#125;public class XiaoMiFactory implements PhoneFactory &#123; @Override public Phone createPhone() &#123; return new XiaoMiPhone(); &#125;&#125;public class HuaWeiFactory implements PhoneFactory &#123; @Override public Phone createPhone() &#123; return new HuaWeiPhone(); &#125;&#125;public class Client &#123; public void buy(Phone p)&#123; System.out.println(&quot;I buy a phone&quot;); p.printPhone(); &#125; public static void main(String[] args) &#123; Client c = new Client(); PhoneFactory pf = new XiaoMiFactory(); Phone p = pf.createPhone(); c.buy(p); &#125;&#125; 优点：工厂方法模式下，如果要新增手机品牌，会新添加对应的产品类和工厂类去实现接口，不需要修改原来存在的代码，符合“开闭原则”。缺点：客户性必须要感应具体的工厂类，也就是判断逻辑移到了客户端。 抽象工厂模式 定义：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。 工厂方法模式和抽象工厂模式基本类似，可以这么理解：当工厂只生产一个产品的时候，即为工厂方法模式，而工厂如果生产两个或以上的商品即变为抽象工厂模式。例如在生产手机的时候也创建操作系统。java代码如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586interface Phone&#123; public void printPhone();&#125;public class XiaoMiPhone implements Phone &#123; @Override public void printPhone() &#123; System.out.println(&quot;This is a XiaoMi Phone&quot;); &#125;&#125;public class HuaWeiPhone implements Phone &#123; @Override public void printPhone() &#123; System.out.println(&quot;This is a HuaWei Phone&quot;); &#125;&#125;public interface OperatingSystem &#123; public void printSystem();&#125;public class XiaoMiSystem implements OperatingSystem&#123; @Override public void printSystem() &#123; System.out.println(&quot;This is a MIUI&quot;); &#125;&#125;public class HuaWeiSystem implements OperatingSystem &#123; @Override public void printSystem() &#123; System.out.println(&quot;This is an EMUI&quot;); &#125;&#125;public interface PhoneFactory &#123; public Phone createPhone(); public OperatingSystem createSystem();&#125;public class XiaoMiFactory implements PhoneFactory &#123; @Override public Phone createPhone() &#123; return new XiaoMiPhone(); &#125; @Override public OperatingSystem createSystem() &#123; return new XiaoMiSystem(); &#125;&#125;public class HuaWeiFactory implements PhoneFactory &#123; @Override public Phone createPhone() &#123; return new HuaWeiPhone(); &#125; @Override public OperatingSystem createSystem() &#123; return new HuaWeiSystem(); &#125;&#125;public class Client &#123; public void buy(Phone p)&#123; System.out.println(&quot;I buy a phone&quot;); p.printPhone(); &#125; public void use(OperatingSystem s) &#123; System.out.println(&quot;Operating System&quot;); s.printSystem(); &#125; public static void main(String[] args) &#123; Client c = new Client(); PhoneFactory pf = new XiaoMiFactory(); Phone p = pf.createPhone(); OperatingSystem os=pf.createSystem(); c.buy(p); c.use(os); &#125;&#125; 与工厂方法模式相比，工厂类多加了一个方法。在使用时，我们不必去在意这个模式到底工厂方法模式还是抽象工厂模式，因为他们之间的演变常常是令人琢磨不透的。经常你会发现，明明使用的工厂方法模式，当新需求来临，稍加修改，加入了一个新方法后，由于类中的产品构成了不同等级结构中的产品族，它就变成抽象工厂模式了；而对于抽象工厂模式，当减少一个方法使的提供的产品不再构成产品族之后，它就演变成了工厂方法模式。]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[设计模式的基本原则]]></title>
    <url>%2F2018%2F12%2F02%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[设计模式的基本原则是软件设计的编程思想，是前人总结的出设计模式的核心原则 一、单一职责原则 单一职责原则：不要存在多于一个导致类变更的原因 顾名思义，就是职责单一，只做自己要的职责，其他的东西我不干，比如说一个互联网公司技术开发有android开发，ios开发，前端开发，后端开发 等 ，每一个职位都需要要专业的人来开发，才能开发出优秀的产品。如果公司为了节约成本，做android的又要搞ios开发，又要搞后端开发，所有的事都由一个人来干，这样不但忙不过来，而且不可能每一项技术都是那么专业，这就表明了单一职责的重要性。 二、里氏替换原则 里氏替换原则：子类可以扩展父类的功能，但不能改变父类原有的功能 里氏替换原则本质就是继承和多态的应用这里面的意思是有1、子类可以实现父类的抽象方法，也可以扩展添加自己的方法2、当子类重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松，比如父类方法的形参为String，那么子类的方法形参为String或String父类3、当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。比如父类的方法的返回值为String，那么子类方法返回值为String或String的子类 三、依赖倒置原则 依赖倒置原则：高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象 说白了，就是面向接口比如我们就常常把访问数据库的代码写成了函数，在访问数据库反复调用，这就叫做高层模块依赖低层模块，但是后来想用其他数据库，问题就来了，我们就不能直接利用高层，解决方法就是面向接口 四、接口隔离原则 接口隔离原则：客户端不应该被强迫地依赖那些根本用不上的方法。 和单一职责原则的区别，其一，单一职责原则原注重的是职责；而接口隔离原则注重对接口依赖的隔离。其二，单一职责原则主要是约束类，其次才是接口和方法，它针对的是程序中的实现和细节；而接口隔离原则主要约束接口接口，主要针对抽象，针对程序整体框架 五、迪米特原则 迪米特法则:一个对象应该对其他对象保持最少的了解 这个就是面向对象的一个特征，对象之前尽量减少耦合，在一个类中应该少出现其他类 六、开闭原则 开闭原则：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭 不要改你以前写的代码，你应该加一些代码去扩展原来的功能，来实现新的需求，对于新功能，不要动不动就改别人的代码，而是在之前代码的基础上添加去扩展新功能]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CoordinatorLayout的AppBarLayout使用]]></title>
    <url>%2F2018%2F12%2F02%2FCoordinatorLayout%E7%9A%84AppBarLayout%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[一、app:layout_scrollFlags五个参数AppBarLayout 继承LinearLayout，在XML里通过app:layout_scrollFlags来设置它的滑动手势,但是前提是根布局是CoordinatorLayout，app:layout_scrollFlags有5个参数，分别是scroll，enterAlways，enterAlwaysCollapsed，snap，exitUntilCollapsed；下面通过xml中设置分析各个参数的作用 scrollchild view伴随着滚动事件而滚出或滚进屏幕。注意两点：第一点，如果使用了其他参数，必定要使用这个参数才能起作用；第二点：如果在这个child View前面的任何其他Child View没有设置这个参数，那么这个Child View的设置将失去作用。scrollview滚动优先级比child view高代码：1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.design.widget.CoordinatorLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt; &lt;android.support.design.widget.AppBarLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;android.support.v7.widget.Toolbar app:layout_scrollFlags=&quot;scroll&quot; app:title=&quot;标题&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;?attr/actionBarSize&quot;/&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;android.support.v4.widget.NestedScrollView android:id=&quot;@+id/ll_first&quot; app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;LinearLayout android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;TextView android:textSize=&quot;40dp&quot; android:text=&quot;A\nB\nC\nD\nE\nF\nG\nH\nI\nJ\nK\nL\nM\nN\nO\nP\nQ\nR\nS\nT\nU\nV\nW\nX\nY\nZ&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; /&gt; &lt;/LinearLayout&gt; &lt;/android.support.v4.widget.NestedScrollView&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; enterAlways快速返回模式。child view滚动优先级比scrollview高代码:12345678910&lt;android.support.design.widget.AppBarLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;android.support.v7.widget.Toolbar app:layout_scrollFlags=&quot;scroll|enterAlways&quot; app:title=&quot;标题&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;?attr/actionBarSize&quot;/&gt; &lt;/android.support.design.widget.AppBarLayout&gt; enterAlwaysCollapsedenterAlways的附加值。这里涉及到Child View的高度和最小高度，向下滚动时，Child View先向下滚动最小高度值，然后Scrolling View开始滚动，到达边界时，Child View再向下滚动，直至显示完全。代码：1234567891011&lt;android.support.design.widget.AppBarLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;android.support.v7.widget.Toolbar app:layout_scrollFlags=&quot;scroll|enterAlways|enterAlwaysCollapsed&quot; app:title=&quot;标题&quot; android:layout_width=&quot;match_parent&quot; android:minHeight=&quot;56dp&quot; android:layout_height=&quot;200dp&quot;/&gt; &lt;/android.support.design.widget.AppBarLayout&gt; exitUntilCollapsed这里也涉及到最小高度。发生向上滚动事件时，Child View向上滚动退出直至最小高度，然后Scrolling View开始滚动。也就是，Child View不会完全退出屏幕。 代码：1234567891011&lt;android.support.design.widget.AppBarLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;android.support.v7.widget.Toolbar app:layout_scrollFlags=&quot;scroll|exitUntilCollapsed&quot; app:title=&quot;标题&quot; android:layout_width=&quot;match_parent&quot; android:minHeight=&quot;56dp&quot; android:layout_height=&quot;200dp&quot;/&gt; &lt;/android.support.design.widget.AppBarLayout&gt; snap简单理解，就是Child View滚动比例的一个吸附效果。也就是说，Child View不会存在局部显示的情况，滚动Child View的部分高度，当我们松开手指时，Child View要么向上全部滚出屏幕，要么向下全部滚进屏幕，有点类似ViewPager的左右滑动。 代码：12345678910&lt;android.support.design.widget.AppBarLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;android.support.v7.widget.Toolbar app:layout_scrollFlags=&quot;scroll|snap&quot; app:title=&quot;标题&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;200dp&quot;/&gt; &lt;/android.support.design.widget.AppBarLayout&gt; 二、与TabLayout结合应用AppBarLayout的子控件不仅仅可以设置为Toolbar，也可以包含其他的View，比如说包裹一个 TabLayout。代码1234567891011121314&lt;android.support.design.widget.AppBarLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;android.support.v7.widget.Toolbar app:layout_scrollFlags=&quot;scroll|enterAlways&quot; app:title=&quot;标题&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;?attr/actionBarSize&quot;/&gt; &lt;android.support.design.widget.TabLayout android:background=&quot;@color/colorAccent&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;/&gt;&lt;/android.support.design.widget.AppBarLayout&gt; 三、与CollapsingToolbarLayout结合应用，实现折叠ToolBarCollapsingToolbarLayout 有几个重要的参数app:contentScrim 设置折叠后的颜色pp:layout_collapseMode 设置子视图折叠模式，有两个参数 1.”pin” 固定模式，在折叠的时候固定在顶端 2. “parallax” 视差模式,在折叠的过程中会有个视差折叠的效果 代码：123456789101112131415161718192021222324252627282930&lt;android.support.design.widget.AppBarLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;android.support.design.widget.CollapsingToolbarLayout app:collapsedTitleGravity=&quot;left&quot; app:expandedTitleGravity=&quot;left|bottom&quot; app:layout_scrollFlags=&quot;scroll|exitUntilCollapsed&quot; app:contentScrim=&quot;@color/colorPrimary&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;250dp&quot;&gt; &lt;ImageView android:src=&quot;@mipmap/liuyifei&quot; android:scaleType=&quot;centerCrop&quot; app:layout_collapseMode=&quot;pin&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; /&gt; &lt;android.support.v7.widget.Toolbar app:title=&quot;标题&quot; android:layout_width=&quot;match_parent&quot; app:layout_collapseMode=&quot;pin&quot; android:layout_height=&quot;?attr/actionBarSize&quot;/&gt; &lt;/android.support.design.widget.CollapsingToolbarLayout&gt; &lt;android.support.design.widget.TabLayout android:background=&quot;@color/colorAccent&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;/&gt; &lt;/android.support.design.widget.AppBarLayout&gt;]]></content>
      <categories>
        <category>android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java反射]]></title>
    <url>%2F2018%2F12%2F02%2FJava%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[定义Java 反射是可以让我们在运行时获取类的方法、属性、父类、接口等类的内部信息的机制。也就是说，反射本质上是一个“反着来”的过程。我们通过new创建一个类的实例时，实际上是由Java虚拟机根据这个类的Class对象在运行时构建出来的，而反射是通过一个类的Class对象来获取它的定义信息，从而我们可以访问到它的属性、方法，知道这个类的父类、实现了哪些接口等信息。 获取Class对象我们知道使用javac能够将.java文件编译为.class文件，这个.class文件包含了我们对类的原始定义信息（父类、接口、构造器、属性、方法等）。.class文件在运行时会被ClassLoader加载到Java虚拟机（JVM）中，当一个.class文件被加载后，JVM会为之生成一个Class对象，我们在程序中通过new实例化的对象实际上是在运行时根据相应的Class对象构造出来的。确切的说，这个Class对象实际上是java.lang.Class泛型类的一个实例，比如Class对象即为一个封装了MyClass类的定义信息的Class实例。由于java.lang.Class类不存在公有构造器，因此我们不能直接实例化这个类，我们可以通过以下方法获取一个Class对象。 在下面的讲解中，我们将以People类和Student类为例：12345678910111213141516171819202122232425262728293031323334353637383940414243public class People &#123; private String name; private int age; public People(String name, int age) &#123; this.name = name; this.age = age; &#125; public int getAge() &#123; return age; &#125; public String getName() &#123; return name; &#125; public void setAge(int age) &#123; this.age = age; &#125; public void setName(String name) &#123; this.name = name; &#125; public void speak() &#123; System.out.println(getName() + &quot; &quot; + getAge()); &#125;&#125; public class Student extends People &#123; private int grade; public Student(String name, int age) &#123; super(name, age); &#125; public Student(String name, int age, int grade) &#123; super(name, age); this.grade = grade; &#125; public int getGrade() &#123; return grade; &#125; public void setGrade(int grade) &#123; this.grade = grade; &#125; private void learn(String course) &#123; System.out.println(name + &quot; learn &quot; + course); &#125;&#125; 通过类名获取Class对象若在编译期知道一个类的名字，我们可以这样获取它的Class对象：1Class&lt;People&gt; peopleClass = People.class; 还有一种根据类的完整路径名获取Class对象的方法如下所示：12//假设People类在com.test包中Class&lt;People&gt; peopleClass = Class.forName(&quot;com.test.People&quot;); 通过对象本身获取其Class对象12People people = new People(&quot;Bill&quot;， 18);Class&lt;People&gt; peopleClass = people.getClass(); 通过反射获取类的构造器一旦我们获得了People的Class 对象，我们便可以通过这个Class 对象获取到People类的原始定义信息。 首先，我们来获取People类的构造器对象，有了这个构造器对象，我们便能够构造出一个People对象出来。比如，我们可以在Student.java中添加以下代码：123456789public static void main(String[] args) &#123; Class&lt;People&gt; pClass = People.class; try &#123; Constructor&lt;People&gt; constructor = pClass.getConstructor(String.class, int.class); People people = constructor.newInstance(&quot;Bill&quot;, 18); people.speak(); &#125; catch (Exception e) &#123; &#125; &#125; 在上面，我们调用getConstructor方法来获取一个People类的构造器对象，由于我们想要获取的构造器的形参类型为String和int，所以我们传入String.class和int.class。有了构造器对象，我们便可以调用newInstance方法来创建一个people对象。注意，当通过反射获取到类的 Constructor、Method、Field对象后，在调用这些对象的方法之前，先将此对象的 accessible 标志设置为 true，以取消 Java 语言访问检查，可以提升反射速度。如以下代码所示：1234Constructor&lt;People&gt; constructor = peopleClass.getConstructor(String.class， int.class);// 设置 constructor 的 Accessible属性为ture以取消Java的访问检查constructor.setAccessible(true); 通过反射获取类中声明的方法获取当前类中声明的方法（不包括从父类继承来的）要获取当前类中声明的所有方法可以通过 Class 中的 getDeclaredMethods 函数，它会获取到当前类中声明的所有方法（包括private、public、static等各种方法），它会返回一个Method对象数组，其中的每个Method对象即表示了一个类中声明的方法。要想获得指定的方法，可以调用getDeclaredMethod(String name, Class… parameterTypes)。如以下代码所示 :123456789101112131415161718192021private static void showDeclaredMethods() &#123; Student student = new Student(&quot;Bill&quot;, 18); //获取Student类声明的所有方法 Method[] methods = student.getClass().getDeclaredMethods(); try &#123; //获取learnMethod对象（封装了learn方法） Method learnMethod = student.getClass().getDeclaredMethod(&quot;learn&quot;, String.class); //获取learn方法的参数列表并打印出来 Class&lt;?&gt;[] paramClasses = learnMethod.getParameterTypes() ; for (Class&lt;?&gt; class : paramClasses) &#123; System.out.println(&quot;learn方法的参数: &quot; + class.getName()); &#125; //判断learn方法是否为private System.out.println(learnMethod.getName() + &quot; is private &quot; + Modifier.isPrivate(learnMethod.getModifiers())); //调用learn方法 learnMethod.invoke(student, &quot;Java Reflection&quot;); &#125; catch (Exception e) &#123; &#125;&#125; 获取当前类和父类中声明的公有方法要获取当前类以及父类中声明的所有 public 方法可以调用getMethods 函数，而要获取某个指定的public方法，可以调用getMethod方法。请看以下代码：12345678910private static void showMethods() &#123; Student student = new Student(&quot;mr.simple&quot;); // 获取所有public方法(包括Student本身的和从父类继承来的） Method[] methods = student.getClass().getMethods(); try &#123; //注意，通过 getMethod只能获取public方法，若尝试获取private方法则会抛出异常 Method learnMethod = student.getClass().getMethod(&quot;learn&quot;, String.class); &#125; catch (Exception e) &#123; &#125;&#125; 通过反射获取类中定义的属性获取属性与获取方法是类似的，只不过把对getMethods() / getDeclaredMethods()方法的调用换成了对getFields() / getDeclaredFields()方法的调用。 #####获取当前类中定义的属性（不包括从父类继承来的属性）要获取当前类中定义的所有属性（包括private、public、static等各种属性）可以调用 Class对象的getDeclaredFields函数；要想获得指定的属性，可以调用getDeclaredField。如以下代码所示:1234567891011121314private static void showDeclaredFields() &#123; Student student = new Student(&quot;Bill&quot;, 18); // 获取当前类中定义的所有属性 Field[] fields = student.getClass().getDeclaredFields(); try &#123; // 获取指定的属性 Field gradeField = student.getClass().getDeclaredField(&quot;grade&quot;); // 获取属性值 System.out.println(&quot;The grade is : &quot; + gradeField.getInt(student)); // 设置属性值 gradeField.set(student, 10); &#125; catch (Exception e) &#123; &#125; &#125; 获取当前类和父类中定义的public属性要获取当前类和父类中定义的所有public 属性可以调用Class对象的getFields 函数，而要获取某个指定的public属性，可以调用getField方法，如以下代码所示：12345private static void showFields() &#123; Student student = new Student(&quot;Bill&quot;， 18); // 获取当前类和父类的所有public属性 Field[] publicFields = student.getClass().getFields(); &#125; 通过反射获取类的父类及类所实现的接口获取父类调用Class对象的getSuperClass方法即可，如以下代码所示：12Student student = new Student(&quot;Bill&quot;, 18);Class&lt;?&gt; superClass = student.getClass().getSuperclass(); 获取所实现的接口要知道一个类实现了哪些接口，只需调用Class对象的getInterfaces方法，如以下代码所示：1234private static void showInterfaces() &#123; Student student = new Student(&quot;Bill&quot;, 19); Class&lt;?&gt;[] interfaces = student.getClass().getInterfaces();&#125; 参考 十分钟理解Java中的反射]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[android视图绘制]]></title>
    <url>%2F2018%2F12%2F02%2Fandroid%E8%A7%86%E5%9B%BE%E7%BB%98%E5%88%B6%2F</url>
    <content type="text"><![CDATA[视图显示在屏幕上要经过三个过程，分别是measure、layout、draw，下面针对三个过程从源码角度解剖视图绘制的过程 一. onMeasure()measure ，顾名思义，就是测量的意思，而onMeasure()就是测量视图的大小。View系统的绘制流程会从ViewRoot的performTraversals()方法中开始，在其内部调用View的measure()方法ViewRoot实现类ViewRootImpl关键代码如下1234567891011...if (mView == null) &#123; return; &#125; Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;measure&quot;); try &#123; mView.measure(childWidthMeasureSpec, childHeightMeasureSpec); &#125; finally &#123; Trace.traceEnd(Trace.TRACE_TAG_VIEW); &#125;... View 的measure()方法是final修饰，不能被继承，内部调用onMeasure()，measure()关键代码12345public final void measure(int widthMeasureSpec, int heightMeasureSpec) &#123;... onMeasure(widthMeasureSpec, heightMeasureSpec);...&#125; View的onMeasure()有一个默认的实现1234protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec)); &#125; 其中setMeasuredDimension()方法是设置视图的大小，getDefaultSize()是通过MeasureSpec获取宽高大小的默认方法，可以看看它的具体实现,12345678910111213141516public static int getDefaultSize(int size, int measureSpec) &#123; int result = size; int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); switch (specMode) &#123; case MeasureSpec.UNSPECIFIED: result = size; break; case MeasureSpec.AT_MOST: case MeasureSpec.EXACTLY: result = specSize; break; &#125; return result; &#125; 我们自定义View时如果想怎么测量控件的大小时，直接覆盖实现onMeasure()方法，测量宽高大小，最后调用setMeasuredDimension()方法设置视图大小。测量布局，ViewGroup中没有实现具体的OnMeasure()方法，因为不同的布局的测量方法不一样，所以要在ViewGroup子类中实现OnMeasure()方法。一个布局ViewGroup一般包含多个子View，这时ViewGroup提供了measureChildren()来测量子View，代码如下12345678910protected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) &#123; final int size = mChildrenCount; final View[] children = mChildren; for (int i = 0; i &lt; size; ++i) &#123; final View child = children[i]; if ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) &#123; measureChild(child, widthMeasureSpec, heightMeasureSpec); &#125; &#125; &#125; 调用了measureChild来测量子View1234567891011protected void measureChild(View child, int parentWidthMeasureSpec, int parentHeightMeasureSpec) &#123; final LayoutParams lp = child.getLayoutParams(); final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom, lp.height); child.measure(childWidthMeasureSpec, childHeightMeasureSpec); &#125; 最终调用了子View的measure()方法测量子View。所以自定义布局如果想自己测量布局的话，首先测量子View，再用setMeasuredDimension()方法测量布局本身 二.onLayout()measure测量完成后，接下来就是layout，顾名思义就是给视图布局，也就是确定视图的位置。ViewRoot的performTraversals()方法在执行完measure()方法后，就会调用layout方法，关键代码如下123... host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight());... 也就是调用了View的layout()方法,下面来看看layout()方法关键代码，参数l,t,r,b分别代表上,下,左,右坐标1234567 public void layout(int l, int t, int r, int b) &#123; if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123; onLayout(changed, l, t, r, b); ... &#125;&#125; layout里面主要调用了onLayout()方法，进入看看12protected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123;&#125; 是一个空实现，是的，因为onLayout()过程是为了确定视图在布局中所在的位置，这个操作应该要布局视图来完成，即父布局决定了子视图的位置，既然这样，看看ViewGroup里面的onLayout()方法123@Override protected abstract void onLayout(boolean changed, int l, int t, int r, int b); 是一个抽象方法，意味着所有的ViewGroup子类都要实现onLayout()方法 下面看看ViewGroup的子类FrameLayout实现的onLayout()方法1234@Override protected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123; layoutChildren(left, top, right, bottom, false /* no force left gravity */); &#125; layoutChildren()关键代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859void layoutChildren(int left, int top, int right, int bottom, boolean forceLeftGravity) &#123; final int count = getChildCount(); ... for (int i = 0; i &lt; count; i++) &#123; final View child = getChildAt(i); if (child.getVisibility() != GONE) &#123; final LayoutParams lp = (LayoutParams) child.getLayoutParams(); final int width = child.getMeasuredWidth(); final int height = child.getMeasuredHeight(); int childLeft; int childTop; int gravity = lp.gravity; if (gravity == -1) &#123; gravity = DEFAULT_CHILD_GRAVITY; &#125; final int layoutDirection = getLayoutDirection(); final int absoluteGravity = Gravity.getAbsoluteGravity(gravity, layoutDirection); final int verticalGravity = gravity &amp; Gravity.VERTICAL_GRAVITY_MASK; switch (absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) &#123; case Gravity.CENTER_HORIZONTAL: childLeft = parentLeft + (parentRight - parentLeft - width) / 2 + lp.leftMargin - lp.rightMargin; break; case Gravity.RIGHT: if (!forceLeftGravity) &#123; childLeft = parentRight - width - lp.rightMargin; break; &#125; case Gravity.LEFT: default: childLeft = parentLeft + lp.leftMargin; &#125; switch (verticalGravity) &#123; case Gravity.TOP: childTop = parentTop + lp.topMargin; break; case Gravity.CENTER_VERTICAL: childTop = parentTop + (parentBottom - parentTop - height) / 2 + lp.topMargin - lp.bottomMargin; break; case Gravity.BOTTOM: childTop = parentBottom - height - lp.bottomMargin; break; default: childTop = parentTop + lp.topMargin; &#125; child.layout(childLeft, childTop, childLeft + width, childTop + height); &#125; &#125; &#125; 代码实现的步骤是先算出上下左右的坐标，再通过child.layout()确认子View的位置。 三. onDraw()layout确定视图位置之后，就要draw啦，顾名思义，就是真正的绘制啦，ViewRoot 执行要layout()之后，接着创建出一个Canvas对象，然后调用draw()方法要执行具体的绘制工作。draw具体的关键代码如下，第二步和第五步很少用到，这里省略了。123456789101112131415161718192021222324252627282930313233343536public void draw(Canvas canvas) &#123; /* * Draw traversal performs several drawing steps which must be executed * in the appropriate order: * * 1. Draw the background * 2. If necessary, save the canvas&apos; layers to prepare for fading * 3. Draw view&apos;s content * 4. Draw children * 5. If necessary, draw the fading edges and restore layers * 6. Draw decorations (scrollbars for instance) */ // Step 1, draw the background, if needed if (!dirtyOpaque) &#123; drawBackground(canvas); &#125; // Step 3, draw the content if (!dirtyOpaque) onDraw(canvas); // Step 4, draw the children dispatchDraw(canvas); // Step 6, draw decorations (foreground, scrollbars) onDrawForeground(canvas); // Step 7, draw the default focus highlight drawDefaultFocusHighlight(canvas); if (debugDraw()) &#123; debugDrawFocus(canvas); &#125; 通过上面的注释大概也看懂什么意思step 1 drawBackground()是绘制背景step 3 onDraw()是绘制内容，点进去看12protected void onDraw(Canvas canvas) &#123; &#125; 是一个空方法，具体的控件有具体的绘制方法step 4 dispatchDraw()是绘制子视图，这个方法也是空实现，ViewGroup才会用到step 6 绘制前景，滚动条 一般情况下我们只要实现onDraw()方法来实现我们绘制的内容]]></content>
      <categories>
        <category>android</category>
      </categories>
  </entry>
</search>
