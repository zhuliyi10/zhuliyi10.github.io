<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F03%2F10%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[Markdown的使用]]></title>
    <url>%2F2019%2F02%2F02%2FMarkdown%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[这是一个标题这是另一个标题 这是第一行标题 这是第一行列表项。 这是第二行列表项。 给出一些例子代码： return shell_exec(“echo $input | $markdown_script”); hello java android ios hello xvdfgd dfsdf dfdf 百度single asteriskssingle asterisks 比如说printf(&quot;hello world)之后也可以 [图片上传失败…(image-4a2488-1553434701067)] 序号 交易名 交易说明 备注 1 prfcfg 菜单配置 可以通过此交易的对应关系 2 gentmo 编译所有交易 p 100000 sysdba 数据库表模型汇总 hel 删除号这是一个注脚测试^注释1]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java8新特性]]></title>
    <url>%2F2018%2F12%2F02%2FJava8%E6%96%B0%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[1、语言新特性1.1、Lambda表达式（也称闭包）Lambda表达式是Java8最大的卖点，它允许交函数作为参数传递给某个方法，或者把代码本身当成数据处理，在java8之前的版本中，只能用匿名内部类代替Lambda表达式。用-&gt;分隔函数形参和函数体， Arrays.asList( “a”, “b”, “d” ).forEach( e -&gt; System.out.println( e ) ); 如果函数体有多条语句，函数体花括号括起来 Arrays.asList( “a”, “b”, “d” ).forEach( e -&gt; { System.out.print( e ); System.out.print( e );} ); Lambda表达示有返回值，其类型和形参类型一样也是由编译器推测出来，如果函数体只有一条语句，则可以不用return，如 Arrays.asList( “a”, “b”, “d” ).sort( ( e1, e2 ) -&gt; e1.compareTo( e2 ) ); 1.2、接口的默认方法和静态方法默认方法使得开发者可以在 不破坏二进制兼容性的前提下，往现存接口中添加新的方法，即不强制那些实现了该接口的类也同时实现这个新加的方法。默认方法和抽象方法之间的区别在于抽象方法需要实现，而默认方法不需要。接口提供的默认方法会被接口的实现类继承或者覆写，例子代码如下：12345678910private interface Defaulable &#123; // Interfaces now allow default methods, the implementer may or // may not implement (override) them. default String notRequired() &#123; return &quot;Default implementation&quot;; &#125; &#125;private static class DefaultableImpl implements Defaulable &#123;&#125; 也可以添加实现123456private static class OverridableImpl implements Defaulable &#123; @Override public String notRequired() &#123; return &quot;Overridden implementation&quot;; &#125;&#125; Java 8带来的另一个有趣的特性是在接口中可以定义静态方法，例子代码如下：123456private interface DefaulableFactory &#123; // Interfaces now allow static methods static Defaulable create( Supplier&lt; Defaulable &gt; supplier ) &#123; return supplier.get(); &#125;&#125; 下面的代码片段整合了默认方法和静态方法的使用场景：1234567public static void main( String[] args ) &#123; Defaulable defaulable = DefaulableFactory.create( DefaultableImpl::new ); System.out.println( defaulable.notRequired() ); defaulable = DefaulableFactory.create( OverridableImpl::new ); System.out.println( defaulable.notRequired() );&#125; 1.3、方法引用第一种方法引用的类型是构造器引用，语法是Class::new，或者更一般的形式：Class::new。注意：这个构造器没有参数。12final Car car = Car.create( Car::new );final List&lt; Car &gt; cars = Arrays.asList( car ); 第二种方法引用的类型是静态方法引用，语法是Class::static_method。注意：这个方法接受一个Car类型的参数。1cars.forEach( Car::collide ); 第三种方法引用的类型是某个类的成员方法的引用，语法是Class::method，注意，这个方法没有定义入参：1cars.forEach( Car::repair ); 第四种方法引用的类型是某个实例对象的成员方法的引用，语法是instance::method。注意：这个方法接受一个Car类型的参数：12final Car police = Car.create( Car::new );cars.forEach( police::follow ); 1.4 重复注解自从Java 5中引入注解以来，这个特性开始变得非常流行，并在各个框架和项目中被广泛使用。不过，注解有一个很大的限制是：在同一个地方不能多次使用同一个注解。Java 8打破了这个限制，引入了重复注解的概念，允许在同一个地方多次使用同一个注解。 在Java 8中使用@Repeatable注解定义重复注解，实际上，这并不是语言层面的改进，而是编译器做的一个trick，底层的技术仍然相同]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java集合]]></title>
    <url>%2F2018%2F12%2F02%2Fjava%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[java集合定义在java.util中 通过上面的接口框架图可以看出：Collection和Map&lt;K,V&gt;是java.util框架中的两个根接口，代表了两种不同的数据结构：集合和映射表。 Collection可以用iterator()迭代器到迭代集合，也可以使用“for each”来遍历，效果和使用iterator一样而List、Set则是继承自Collection下最核心的两个接口，List有序并可以通过整数索引来访问，Set不可重复 Map&lt;K,V&gt;从键映射到值的一个对象，键不能重复，每个键至多映射到一个值，从键不能重复这个特点用Set来实现TreeMap是有序的，效率比 HashMap 低HashMap是无序的，速度很快LinkedHashMap，结合两者的特点，有序不过没HashMap 快 List：特性:有序。ArrayList 基于数组；LinkedList 基于双向链表Set：特性:不可重复。TreeSet 有顺序，HashSet高效，LinkedHashSet 有序也快的SetMap：映射集合。key是set,value是collection，HashMap的key对应的是HashSet，TreeHash的key对应的是TreeSet，LinkedHashMap的key对应的key是LinkedHashSet.]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[如果使用hexo在github上搭建自己的博客]]></title>
    <url>%2F2018%2F12%2F02%2F%E5%A6%82%E6%9E%9C%E4%BD%BF%E7%94%A8hexo%E5%9C%A8github%E4%B8%8A%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[目前的写技术的文章的工具比较多，比如简书，掘金等第三方写作平台，用起来比较方便，那为什么还要搭建自己的博客呢，因为作为开发者没有个人的博客都显示不“了高逼格”，而且第三方写作平台主题都是定制好，自由性不好。个人博客工具之前用的比较多的wordpress，到现在的hexo，越来越简洁易用，下面直接说说今天的主角hexo以及怎么得用hexo搭建开发的个人博客。 hexo是什么hexo可以理解成是基于node.js制作的一个博客工具，hexo不需要部署到我们的服务器上，我们能能markdown编辑markdown文章，然后hexo帮我们生成静态的html页面，然后交生成的html文件上传到服务器上，hexo就是一个静态页面生成、上传的工具。 环境 git 下载安装git客户端 Node.js 下载安装Node.js Github账号 注册github帐号，Repository name为”自己的名称+.github.io”，然后创建。 配置github的ssh密码 首先在本地生成ssh密码，首先在桌面空白处鼠标右键选择Git Bash Here，然后输入：1ssh-keygen -t rsa -C &quot;your&apos;s emaill address&quot; 其中your’s emaill address填入你的邮箱地址，回车，会提示你文件保存的路径，回车确认，然后输入github密码，输入确定，这时会生成两个文件，一个是id_rsa，另一个是id_rsa.pub，打开id_rsa.pub，复制里面的全部内容 登陆github,点击头像，选择SSH and GPG keys,选择New SSH key输入title名称，自定义，把上面复制的Key粘贴到Key里面，点击Add SSH key，添加成功 安装Hexo打开命令行，输入1npm install -g hexo-cli 等待一段时间后安装成功，通过hexo -v测试是否安装成功创建一个空文件夹，如blog，存放博客信息，然后通过命令行进入该目录下，依次输入执行以下命令1234hexo initnpm installhexo ghexo s 这时在浏览器输入http://localhost:4000/就看到本地成功的博客页面了 配置Hexo到Github找到我们刚刚创建的博客文件夹，打到_config.yml文件，打开修改最后的成下面的样子 1234deploy: type: git repository: https://github.com/yourname/yourname.github.io.git branch: master 注意yourname是你github的用户名保存后执行,生成和上传静态页面到github123hexo cleanhexo ghexo d 注：如果出现如下异常1ERROR Deployer not found: git 需要1npm install hexo-deployer-git --save 这样你的博客地址就是https://yourname.github.io了]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[设计模式之单例模式]]></title>
    <url>%2F2018%2F12%2F02%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[什么是设计模式？其实简单的理解就是前人留下来的一些经验总结 一、懒汉式懒汉式的特点就是在getInstance()方法时候才进行初始化1234567891011public class Singleton &#123; private static Singleton instance; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 这种单列模式在线程并发时候就可能会产生多个实例，称为线程不安全 二、懒汉式（线程安全）1234567891011public class Singleton &#123; private static Singleton instance; private Singleton() &#123; &#125; public static synchronized Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 可以看出加入同步关键字synchronized这样实现了线程的安全，但是每次调用都会实现同步，导致效果很低 ##三、双重检测机制123456789101112131415161718public class Singleton &#123; private static Singleton instance; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; if(instance==null)&#123; synchronized (Singleton.class) &#123; if (instance == null) &#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; 二次检查实例是否创建，第一次检查没有创建，进行同步，同步后第二次检查，这种方法看似很完美，不过也有缺点，在于instance = new Singleton();这条语句，新建对象包含了下面三个步骤：1、分配内存2、执行构造方法的初始化3、将对象指向分配的内存空间 由于java编译器为了尽可能减少内存操作速度远慢于CPU运行速度所带来的CPU空置的影响，虚拟机会按照自己的一些规则将程序编写顺序打乱——即写在后面的代码在时间顺序上可能会先执行，而写在前面的代码会后执行——以尽可能充分地利用CPU就会出现指令重排序(happen-before)，从而导致上面的三个步骤执行顺序发生改变。正常情况下是123，但是如果指令重排后执行为1,3,2那么久会导致instance 为空，进而导致程序出现问题。解决方法呢？java中有一个关键字volatile，有一个作用就是防止指令重排。 private static Singleton instance; 饿汉式饿汉式的特点就是在类加载的时候就进行初始化操作12345678910public class Singleton&#123; private static final Singleton instance = new Singleton(); private Singleton() &#123; &#125; public static Singleton getInstance()&#123; return instance; &#125;&#125; 与懒汉式相比，它是线程安全的，无需用同步关键字修饰优点就是由于没有加锁，执行效率比较高缺点就是在类加载时就初始化，会浪费内存 ##]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[设计模式的基本原则]]></title>
    <url>%2F2018%2F12%2F02%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[设计模式的基本原则是软件设计的编程思想，是前人总结的出设计模式的核心原则 一、单一职责原则 单一职责原则：不要存在多于一个导致类变更的原因 顾名思义，就是职责单一，只做自己要的职责，其他的东西我不干，比如说一个互联网公司技术开发有android开发，ios开发，前端开发，后端开发 等 ，每一个职位都需要要专业的人来开发，才能开发出优秀的产品。如果公司为了节约成本，做android的又要搞ios开发，又要搞后端开发，所有的事都由一个人来干，这样不但忙不过来，而且不可能每一项技术都是那么专业，这就表明了单一职责的重要性。 二、里氏替换原则 里氏替换原则：子类可以扩展父类的功能，但不能改变父类原有的功能 里氏替换原则本质就是继承和多态的应用这里面的意思是有1、子类可以实现父类的抽象方法，也可以扩展添加自己的方法2、当子类重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松，比如父类方法的形参为String，那么子类的方法形参为String或String父类3、当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。比如父类的方法的返回值为String，那么子类方法返回值为String或String的子类 三、依赖倒置原则 依赖倒置原则：高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象 说白了，就是面向接口比如我们就常常把访问数据库的代码写成了函数，在访问数据库反复调用，这就叫做高层模块依赖低层模块，但是后来想用其他数据库，问题就来了，我们就不能直接利用高层，解决方法就是面向接口 四、接口隔离原则 接口隔离原则：客户端不应该被强迫地依赖那些根本用不上的方法。 和单一职责原则的区别，其一，单一职责原则原注重的是职责；而接口隔离原则注重对接口依赖的隔离。其二，单一职责原则主要是约束类，其次才是接口和方法，它针对的是程序中的实现和细节；而接口隔离原则主要约束接口接口，主要针对抽象，针对程序整体框架 五、迪米特原则 迪米特法则:一个对象应该对其他对象保持最少的了解 这个就是面向对象的一个特征，对象之前尽量减少耦合，在一个类中应该少出现其他类 六、开闭原则 开闭原则：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭 不要改你以前写的代码，你应该加一些代码去扩展原来的功能，来实现新的需求，对于新功能，不要动不动就改别人的代码，而是在之前代码的基础上添加去扩展新功能]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[设计模式之工厂模式]]></title>
    <url>%2F2018%2F12%2F02%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[工厂模式包括简单工厂模式、工厂方法模式、抽象工厂模式。工厂模式形式和特点都很相似，他们最终的目的都是为了解耦。 简单工厂模式 定义：专门定义一个类用来创建其他类的实例，被创建的实例通常都具有共同的父类。 例如有客户要选择两个品牌的手机，小米和华为，这时候客户只需要把选择type交给Factory，Factory根据type来创建各品牌手机的实例。简单工厂java代码实现如下123456789101112131415161718192021222324252627282930313233343536373839404142434445interface Phone&#123; public void printPhone();&#125;public class XiaoMiPhone implements Phone &#123; @Override public void printPhone() &#123; System.out.println(&quot;This is a XiaoMi Phone&quot;); &#125;&#125;public class HuaWeiPhone implements Phone &#123; @Override public void printPhone() &#123; System.out.println(&quot;This is a HuaWei Phone&quot;); &#125;&#125;public class PhoneFactory &#123; public Phone createPhone(String type) &#123; Phone p = null; if(type.equals(&quot;xiaomi&quot;)) &#123; p = new XiaoMiPhone (); &#125;else if(type.equals(&quot;huawei&quot;)) &#123; p = new HuaWeiPhone (); &#125; return p; &#125;&#125;public class Client &#123; public void buy(Phone p)&#123; System.out.println(&quot;I buy a phone&quot;); p.printComputer(); &#125; public static void main(String[] args) &#123; Client c = new Client(); PhoneFactory pf = new PhoneFactory (); Phone p= pf .createPhone(&quot;xiaomi&quot;); c.buy(p); &#125;&#125; 但是问题来了如果，如果客户来选择其他手机品牌MeiZu，就需要修改工厂类PhoneFactory r 代码，添加type为meizu的品牌。违反了对扩展开放，对修改关闭的原则，即“开闭原则” 开闭原则：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭 所以简单工厂模式的优缺点：优点：工厂Factory负责产生具体的实例对象 ，实现具体的逻辑，通过客户的输入就可以得到具体的实例，客户不需要知道各类型实例的具体实现，交给工厂即可。缺点：违反了“开闭原则”。 针对简单工厂模式的缺点，我们需要改良工厂模式，这就出现了工厂方法模式。 工厂方法模式 定义：定义一个用来创建对象的接口，让子类决定实例化哪一个类，让子类决定实例化延迟到子类。 实现方式与简单工厂模式的区别是，把之前的PhoneFactory抽象成一个接口，每一个手机品牌都有一个对应的PhoneFactory的实现类。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051interface Phone&#123; public void printPhone();&#125;public class XiaoMiPhone implements Phone &#123; @Override public void printPhone() &#123; System.out.println(&quot;This is a XiaoMi Phone&quot;); &#125;&#125;public class HuaWeiPhone implements Phone &#123; @Override public void printPhone() &#123; System.out.println(&quot;This is a HuaWei Phone&quot;); &#125;&#125;public interface PhoneFactory &#123; public Phone createPhone();&#125;public class XiaoMiFactory implements PhoneFactory &#123; @Override public Phone createPhone() &#123; return new XiaoMiPhone(); &#125;&#125;public class HuaWeiFactory implements PhoneFactory &#123; @Override public Phone createPhone() &#123; return new HuaWeiPhone(); &#125;&#125;public class Client &#123; public void buy(Phone p)&#123; System.out.println(&quot;I buy a phone&quot;); p.printPhone(); &#125; public static void main(String[] args) &#123; Client c = new Client(); PhoneFactory pf = new XiaoMiFactory(); Phone p = pf.createPhone(); c.buy(p); &#125;&#125; 优点：工厂方法模式下，如果要新增手机品牌，会新添加对应的产品类和工厂类去实现接口，不需要修改原来存在的代码，符合“开闭原则”。缺点：客户性必须要感应具体的工厂类，也就是判断逻辑移到了客户端。 抽象工厂模式 定义：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。 工厂方法模式和抽象工厂模式基本类似，可以这么理解：当工厂只生产一个产品的时候，即为工厂方法模式，而工厂如果生产两个或以上的商品即变为抽象工厂模式。例如在生产手机的时候也创建操作系统。java代码如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586interface Phone&#123; public void printPhone();&#125;public class XiaoMiPhone implements Phone &#123; @Override public void printPhone() &#123; System.out.println(&quot;This is a XiaoMi Phone&quot;); &#125;&#125;public class HuaWeiPhone implements Phone &#123; @Override public void printPhone() &#123; System.out.println(&quot;This is a HuaWei Phone&quot;); &#125;&#125;public interface OperatingSystem &#123; public void printSystem();&#125;public class XiaoMiSystem implements OperatingSystem&#123; @Override public void printSystem() &#123; System.out.println(&quot;This is a MIUI&quot;); &#125;&#125;public class HuaWeiSystem implements OperatingSystem &#123; @Override public void printSystem() &#123; System.out.println(&quot;This is an EMUI&quot;); &#125;&#125;public interface PhoneFactory &#123; public Phone createPhone(); public OperatingSystem createSystem();&#125;public class XiaoMiFactory implements PhoneFactory &#123; @Override public Phone createPhone() &#123; return new XiaoMiPhone(); &#125; @Override public OperatingSystem createSystem() &#123; return new XiaoMiSystem(); &#125;&#125;public class HuaWeiFactory implements PhoneFactory &#123; @Override public Phone createPhone() &#123; return new HuaWeiPhone(); &#125; @Override public OperatingSystem createSystem() &#123; return new HuaWeiSystem(); &#125;&#125;public class Client &#123; public void buy(Phone p)&#123; System.out.println(&quot;I buy a phone&quot;); p.printPhone(); &#125; public void use(OperatingSystem s) &#123; System.out.println(&quot;Operating System&quot;); s.printSystem(); &#125; public static void main(String[] args) &#123; Client c = new Client(); PhoneFactory pf = new XiaoMiFactory(); Phone p = pf.createPhone(); OperatingSystem os=pf.createSystem(); c.buy(p); c.use(os); &#125;&#125; 与工厂方法模式相比，工厂类多加了一个方法。在使用时，我们不必去在意这个模式到底工厂方法模式还是抽象工厂模式，因为他们之间的演变常常是令人琢磨不透的。经常你会发现，明明使用的工厂方法模式，当新需求来临，稍加修改，加入了一个新方法后，由于类中的产品构成了不同等级结构中的产品族，它就变成抽象工厂模式了；而对于抽象工厂模式，当减少一个方法使的提供的产品不再构成产品族之后，它就演变成了工厂方法模式。]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java反射]]></title>
    <url>%2F2018%2F12%2F02%2FJava%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[定义Java 反射是可以让我们在运行时获取类的方法、属性、父类、接口等类的内部信息的机制。也就是说，反射本质上是一个“反着来”的过程。我们通过new创建一个类的实例时，实际上是由Java虚拟机根据这个类的Class对象在运行时构建出来的，而反射是通过一个类的Class对象来获取它的定义信息，从而我们可以访问到它的属性、方法，知道这个类的父类、实现了哪些接口等信息。 获取Class对象我们知道使用javac能够将.java文件编译为.class文件，这个.class文件包含了我们对类的原始定义信息（父类、接口、构造器、属性、方法等）。.class文件在运行时会被ClassLoader加载到Java虚拟机（JVM）中，当一个.class文件被加载后，JVM会为之生成一个Class对象，我们在程序中通过new实例化的对象实际上是在运行时根据相应的Class对象构造出来的。确切的说，这个Class对象实际上是java.lang.Class泛型类的一个实例，比如Class对象即为一个封装了MyClass类的定义信息的Class实例。由于java.lang.Class类不存在公有构造器，因此我们不能直接实例化这个类，我们可以通过以下方法获取一个Class对象。 在下面的讲解中，我们将以People类和Student类为例：12345678910111213141516171819202122232425262728293031323334353637383940414243public class People &#123; private String name; private int age; public People(String name, int age) &#123; this.name = name; this.age = age; &#125; public int getAge() &#123; return age; &#125; public String getName() &#123; return name; &#125; public void setAge(int age) &#123; this.age = age; &#125; public void setName(String name) &#123; this.name = name; &#125; public void speak() &#123; System.out.println(getName() + &quot; &quot; + getAge()); &#125;&#125; public class Student extends People &#123; private int grade; public Student(String name, int age) &#123; super(name, age); &#125; public Student(String name, int age, int grade) &#123; super(name, age); this.grade = grade; &#125; public int getGrade() &#123; return grade; &#125; public void setGrade(int grade) &#123; this.grade = grade; &#125; private void learn(String course) &#123; System.out.println(name + &quot; learn &quot; + course); &#125;&#125; 通过类名获取Class对象若在编译期知道一个类的名字，我们可以这样获取它的Class对象：1Class&lt;People&gt; peopleClass = People.class; 还有一种根据类的完整路径名获取Class对象的方法如下所示：12//假设People类在com.test包中Class&lt;People&gt; peopleClass = Class.forName(&quot;com.test.People&quot;); 通过对象本身获取其Class对象12People people = new People(&quot;Bill&quot;， 18);Class&lt;People&gt; peopleClass = people.getClass(); 通过反射获取类的构造器一旦我们获得了People的Class 对象，我们便可以通过这个Class 对象获取到People类的原始定义信息。 首先，我们来获取People类的构造器对象，有了这个构造器对象，我们便能够构造出一个People对象出来。比如，我们可以在Student.java中添加以下代码：123456789public static void main(String[] args) &#123; Class&lt;People&gt; pClass = People.class; try &#123; Constructor&lt;People&gt; constructor = pClass.getConstructor(String.class, int.class); People people = constructor.newInstance(&quot;Bill&quot;, 18); people.speak(); &#125; catch (Exception e) &#123; &#125; &#125; 在上面，我们调用getConstructor方法来获取一个People类的构造器对象，由于我们想要获取的构造器的形参类型为String和int，所以我们传入String.class和int.class。有了构造器对象，我们便可以调用newInstance方法来创建一个people对象。注意，当通过反射获取到类的 Constructor、Method、Field对象后，在调用这些对象的方法之前，先将此对象的 accessible 标志设置为 true，以取消 Java 语言访问检查，可以提升反射速度。如以下代码所示：1234Constructor&lt;People&gt; constructor = peopleClass.getConstructor(String.class， int.class);// 设置 constructor 的 Accessible属性为ture以取消Java的访问检查constructor.setAccessible(true); 通过反射获取类中声明的方法获取当前类中声明的方法（不包括从父类继承来的）要获取当前类中声明的所有方法可以通过 Class 中的 getDeclaredMethods 函数，它会获取到当前类中声明的所有方法（包括private、public、static等各种方法），它会返回一个Method对象数组，其中的每个Method对象即表示了一个类中声明的方法。要想获得指定的方法，可以调用getDeclaredMethod(String name, Class… parameterTypes)。如以下代码所示 :123456789101112131415161718192021private static void showDeclaredMethods() &#123; Student student = new Student(&quot;Bill&quot;, 18); //获取Student类声明的所有方法 Method[] methods = student.getClass().getDeclaredMethods(); try &#123; //获取learnMethod对象（封装了learn方法） Method learnMethod = student.getClass().getDeclaredMethod(&quot;learn&quot;, String.class); //获取learn方法的参数列表并打印出来 Class&lt;?&gt;[] paramClasses = learnMethod.getParameterTypes() ; for (Class&lt;?&gt; class : paramClasses) &#123; System.out.println(&quot;learn方法的参数: &quot; + class.getName()); &#125; //判断learn方法是否为private System.out.println(learnMethod.getName() + &quot; is private &quot; + Modifier.isPrivate(learnMethod.getModifiers())); //调用learn方法 learnMethod.invoke(student, &quot;Java Reflection&quot;); &#125; catch (Exception e) &#123; &#125;&#125; 获取当前类和父类中声明的公有方法要获取当前类以及父类中声明的所有 public 方法可以调用getMethods 函数，而要获取某个指定的public方法，可以调用getMethod方法。请看以下代码：12345678910private static void showMethods() &#123; Student student = new Student(&quot;mr.simple&quot;); // 获取所有public方法(包括Student本身的和从父类继承来的） Method[] methods = student.getClass().getMethods(); try &#123; //注意，通过 getMethod只能获取public方法，若尝试获取private方法则会抛出异常 Method learnMethod = student.getClass().getMethod(&quot;learn&quot;, String.class); &#125; catch (Exception e) &#123; &#125;&#125; 通过反射获取类中定义的属性获取属性与获取方法是类似的，只不过把对getMethods() / getDeclaredMethods()方法的调用换成了对getFields() / getDeclaredFields()方法的调用。 #####获取当前类中定义的属性（不包括从父类继承来的属性）要获取当前类中定义的所有属性（包括private、public、static等各种属性）可以调用 Class对象的getDeclaredFields函数；要想获得指定的属性，可以调用getDeclaredField。如以下代码所示:1234567891011121314private static void showDeclaredFields() &#123; Student student = new Student(&quot;Bill&quot;, 18); // 获取当前类中定义的所有属性 Field[] fields = student.getClass().getDeclaredFields(); try &#123; // 获取指定的属性 Field gradeField = student.getClass().getDeclaredField(&quot;grade&quot;); // 获取属性值 System.out.println(&quot;The grade is : &quot; + gradeField.getInt(student)); // 设置属性值 gradeField.set(student, 10); &#125; catch (Exception e) &#123; &#125; &#125; 获取当前类和父类中定义的public属性要获取当前类和父类中定义的所有public 属性可以调用Class对象的getFields 函数，而要获取某个指定的public属性，可以调用getField方法，如以下代码所示：12345private static void showFields() &#123; Student student = new Student(&quot;Bill&quot;， 18); // 获取当前类和父类的所有public属性 Field[] publicFields = student.getClass().getFields(); &#125; 通过反射获取类的父类及类所实现的接口获取父类调用Class对象的getSuperClass方法即可，如以下代码所示：12Student student = new Student(&quot;Bill&quot;, 18);Class&lt;?&gt; superClass = student.getClass().getSuperclass(); 获取所实现的接口要知道一个类实现了哪些接口，只需调用Class对象的getInterfaces方法，如以下代码所示：1234private static void showInterfaces() &#123; Student student = new Student(&quot;Bill&quot;, 19); Class&lt;?&gt;[] interfaces = student.getClass().getInterfaces();&#125; 参考 十分钟理解Java中的反射]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
</search>
